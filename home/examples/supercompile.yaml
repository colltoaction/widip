#!/usr/bin/env titi
# Supercompilation Example
# Demonstrates Futamura projections and program specialization

- "╔════════════════════════════════════════╗"
- "║   SUPERCOMPILATION & SPECIALIZATION    ║"
- "╚════════════════════════════════════════╝"

- "\n=== Step 1: Program Specialization ==="
- "Specializing a power function..."

# Complex recursive definitions are better defined as named anchors in a mapping
- definitions:
    power: &power
      - !program "check_exponent"
      - !choice
        - 1
        - !seq [ !program "decrement", *power, !program "multiply" ]

# Then we can use them
- &power2 !specializer [ *power, 2 ]

- "Executing specialized power_2(3)..."
- !seq [ 3, *power2, !print "" ]

- "\n=== Step 2: Futamura Projections ==="

- &compiled !futamura1 [ !program "python_interpreter", "x = x * x" ]

- "Running compiled program on 4..."
- !seq [ 4, *compiled, !print "" ]

- &compiler !futamura2 [ !program "python_interpreter", !program "specializer" ]

- "Compiler generated."

- &cogen !futamura3 [ !program "specializer" ]

- "COGEN generated."

- "\n=== Step 3: Recursive Factorial Supercompilation ==="

- recursive_definitions:
    factorial: &fact
      - !program "test_zero"
      - !choice
        - 1
        - !seq [ !copy 2, !seq [ !program "dec", *fact, !program "mul" ] ]

- &opt_fact !supercompile *fact

- "Executing optimized factorial(5)..."
- !seq [ 5, *opt_fact, !print "" ]

- "\n╔════════════════════════════════════════╗"
- "║       SUPERCOMPILATION COMPLETE        ║"
- "╚════════════════════════════════════════╝"
