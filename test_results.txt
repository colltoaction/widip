â†’ Running pytest on YAML Test Suite...
PYTHONPATH=$PYTHONPATH:lib/computer/../ python3 -m pytest tests/test_yaml_suite.py -v
============================= test session starts ==============================
platform linux -- Python 3.13.5, pytest-9.0.2, pluggy-1.5.0 -- /home/colltoaction/miniconda3/bin/python3
cachedir: .pytest_cache
rootdir: /home/colltoaction/GitHub/widip
configfile: pytest.ini
plugins: anyio-4.12.0, asyncio-1.3.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 351 items

tests/test_yaml_suite.py::test_yaml_suite[T5N4---- |\n literal\n \u2014\u2014\xbbtext\n\u21b5\n\u21b5] PASSED [  0%]
tests/test_yaml_suite.py::test_yaml_suite[JTV5-? a\n  true\n: null\n  d\n? e\n  42] PASSED [  0%]
tests/test_yaml_suite.py::test_yaml_suite[6XDY----\n---] PASSED          [  0%]
tests/test_yaml_suite.py::test_yaml_suite[M5C3-literal: |2\n  value\nfolded:\n   !foo\n  >1\n value] FAILED [  1%]
tests/test_yaml_suite.py::test_yaml_suite[3HFZ----\nkey: value\n... invalid] FAILED [  1%]
tests/test_yaml_suite.py::test_yaml_suite[54T7-{foo: you, bar: far}] PASSED [  1%]
tests/test_yaml_suite.py::test_yaml_suite[57H4-sequence: !!seq\n- entry\n- !!seq\n - nested\nmapping: !!map\n foo: bar] FAILED [  1%]
tests/test_yaml_suite.py::test_yaml_suite[A6F9-strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text] FAILED [  2%]
tests/test_yaml_suite.py::test_yaml_suite[P2EQ----\n- { y: z }- invalid] PASSED [  2%]
tests/test_yaml_suite.py::test_yaml_suite[KH5V-"1 inline\\ttab"] PASSED  [  2%]
tests/test_yaml_suite.py::test_yaml_suite[K3WX----\n{ "foo" # comment\n  :bar }] FAILED [  3%]
tests/test_yaml_suite.py::test_yaml_suite[K54U----\xbbscalar] PASSED     [  3%]
tests/test_yaml_suite.py::test_yaml_suite[EHF6-!!map {\n  k: !!seq\n  [ a, !!str b]\n}] PASSED [  3%]
tests/test_yaml_suite.py::test_yaml_suite[TS54->\n ab\n cd\n\u2423\n ef\n\n\n gh] PASSED [  3%]
tests/test_yaml_suite.py::test_yaml_suite[DMG6-key:\n  ok: 1\n wrong: 2] FAILED [  4%]
tests/test_yaml_suite.py::test_yaml_suite[SKE5----\nseq:\n &anchor\n- a\n- b] FAILED [  4%]
tests/test_yaml_suite.py::test_yaml_suite[ZH7C-&a a: b\nc: &d d] FAILED  [  4%]
tests/test_yaml_suite.py::test_yaml_suite[G992->\n folded\n text\n\u21b5\n\u21b5] PASSED [  5%]
tests/test_yaml_suite.py::test_yaml_suite[9CWY-key:\n - item1\n - item2\ninvalid] FAILED [  5%]
tests/test_yaml_suite.py::test_yaml_suite[L24T-foo: |\n  x\n\u2423\u2423\u2423] PASSED [  5%]
tests/test_yaml_suite.py::test_yaml_suite[96NN-foo: |-\n \u2014\u2014\xbbbar] FAILED [  5%]
tests/test_yaml_suite.py::test_yaml_suite[G9HC----\nseq:\n&anchor\n- a\n- b] FAILED [  6%]
tests/test_yaml_suite.py::test_yaml_suite[P94K-key:    # Comment\n        # lines\n  value\n\u21b5\n\u21b5] FAILED [  6%]
tests/test_yaml_suite.py::test_yaml_suite[652Z-{ ?foo: bar,\nbar: 42\n}] PASSED [  6%]
tests/test_yaml_suite.py::test_yaml_suite[8CWC----\nkey ends with two colons::: value] PASSED [  7%]
tests/test_yaml_suite.py::test_yaml_suite[C2DT-{\n"adjacent":value,\n"readable": value,\n"empty":\n}] FAILED [  7%]
tests/test_yaml_suite.py::test_yaml_suite[3GZX-First occurrence: &anchor Foo\nSecond occurrence: *anchor\nOverride anchor: &anchor Bar\nReuse anchor: *anchor] FAILED [  7%]
tests/test_yaml_suite.py::test_yaml_suite[V55R-- &a a\n- &b b\n- *a\n- *b] FAILED [  7%]
tests/test_yaml_suite.py::test_yaml_suite[AVM7-\u220e] PASSED            [  8%]
tests/test_yaml_suite.py::test_yaml_suite[27NA-%YAML 1.2\n--- text] FAILED [  8%]
tests/test_yaml_suite.py::test_yaml_suite[58MP-{x: :x}] PASSED           [  8%]
tests/test_yaml_suite.py::test_yaml_suite[Q9WF-{ first: Sammy, last: Sosa }:\n# Statistics:\n  hr:  # Home runs\n     65\n  avg: # Average\n   0.278] FAILED [  9%]
tests/test_yaml_suite.py::test_yaml_suite[NP9H-"folded\u2423\nto a space,\xbb\n\u2423\nto a line feed, or \xbb\\\n \\ \xbbnon-content"] FAILED [  9%]
tests/test_yaml_suite.py::test_yaml_suite[SSW6----\n'here''s to "quotes"'] PASSED [  9%]
tests/test_yaml_suite.py::test_yaml_suite[4JVG-top1: &node1\n  &k1 key1: val1\ntop2: &node2\n  &v2 val2] FAILED [  9%]
tests/test_yaml_suite.py::test_yaml_suite[LE5A-- !!str "a"\n- 'b'\n- &anchor "c"\n- *anchor\n- !!str] PASSED [ 10%]
tests/test_yaml_suite.py::test_yaml_suite[R52L----\n{ top1: [item1, {key2: value2}, item3], top2: value2 }] PASSED [ 10%]
tests/test_yaml_suite.py::test_yaml_suite[BS4K-word1  # comment\nword2] FAILED [ 10%]
tests/test_yaml_suite.py::test_yaml_suite[K858-strip: >-\n\nclip: >\n\nkeep: |+\n\u21b5] FAILED [ 11%]
tests/test_yaml_suite.py::test_yaml_suite[3UYS-escaped slash: "a\\/b"] PASSED [ 11%]
tests/test_yaml_suite.py::test_yaml_suite[8MK2-! a] PASSED               [ 11%]
tests/test_yaml_suite.py::test_yaml_suite[HRE5----\ndouble: "quoted \\' scalar"] PASSED [ 11%]
tests/test_yaml_suite.py::test_yaml_suite[9J7A-foo:\n  bar: baz] PASSED  [ 12%]
tests/test_yaml_suite.py::test_yaml_suite[9WXW-# Private\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"] FAILED [ 12%]
tests/test_yaml_suite.py::test_yaml_suite[5U3A-key: - a\n     - b] FAILED [ 12%]
tests/test_yaml_suite.py::test_yaml_suite[6ZKB-Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20] FAILED [ 13%]
tests/test_yaml_suite.py::test_yaml_suite[L94M-? !!str a\n: !!int 47\n? c\n: !!str d] FAILED [ 13%]
tests/test_yaml_suite.py::test_yaml_suite[4V8U----\nplain\\value\\with\\backslashes] PASSED [ 13%]
tests/test_yaml_suite.py::test_yaml_suite[3ALJ-- - s1_i1\n  - s1_i2\n- s2] FAILED [ 13%]
tests/test_yaml_suite.py::test_yaml_suite[B3HG---- >\n folded\n text\n\u21b5\n\u21b5] PASSED [ 14%]
tests/test_yaml_suite.py::test_yaml_suite[TE2A-block mapping:\n key: value] PASSED [ 14%]
tests/test_yaml_suite.py::test_yaml_suite[4WA9-- aaa: |2\n    xxx\n  bbb: |\n    xxx] FAILED [ 14%]
tests/test_yaml_suite.py::test_yaml_suite[CUP7-anchored: !local &anchor value\nalias: *anchor] FAILED [ 15%]
tests/test_yaml_suite.py::test_yaml_suite[8QBE-key:\n - item1\n - item2] FAILED [ 15%]
tests/test_yaml_suite.py::test_yaml_suite[SM9W--\u220e] PASSED           [ 15%]
tests/test_yaml_suite.py::test_yaml_suite[DWX9-|\n\u2423\n\u2423\u2423\n  literal\n\u2423\u2423\u2423\n\u2423\u2423\n  text\n\n # Comment] PASSED [ 15%]
tests/test_yaml_suite.py::test_yaml_suite[5MUD----\n{ "foo"\n  :bar }] FAILED [ 16%]
tests/test_yaml_suite.py::test_yaml_suite[ZWK4----\na: 1\n? b\n&anchor c: 3] FAILED [ 16%]
tests/test_yaml_suite.py::test_yaml_suite[6BCT-- foo:\u2014\xbb bar\n- - baz\n  -\xbbbaz] PASSED [ 16%]
tests/test_yaml_suite.py::test_yaml_suite[6S55-key:\n - bar\n - baz\n invalid] FAILED [ 17%]
tests/test_yaml_suite.py::test_yaml_suite[RZP5-a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne: &node # lala\n - x: y\nblock: > # lala\n  abcde] FAILED [ 17%]
tests/test_yaml_suite.py::test_yaml_suite[8XYN----\n- &\U0001f601 unicode anchor] PASSED [ 17%]
tests/test_yaml_suite.py::test_yaml_suite[6WLZ-# Private\n---\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"] FAILED [ 17%]
tests/test_yaml_suite.py::test_yaml_suite[JEF9-- |+\n\u21b5\n\u21b5] PASSED [ 18%]
tests/test_yaml_suite.py::test_yaml_suite[WZ62-{\n  foo : !!str,\n  !!str : bar,\n}] PASSED [ 18%]
tests/test_yaml_suite.py::test_yaml_suite[L383---- foo  # comment\n--- foo  # comment] FAILED [ 18%]
tests/test_yaml_suite.py::test_yaml_suite[ZL4Z----\na: 'b': c] PASSED    [ 19%]
tests/test_yaml_suite.py::test_yaml_suite[AZ63-one:\n- 2\n- 3\nfour: 5] FAILED [ 19%]
tests/test_yaml_suite.py::test_yaml_suite[74H7-!!str a: b\nc: !!int 42\ne: !!str f\ng: h\n!!str 23: !!bool false] FAILED [ 19%]
tests/test_yaml_suite.py::test_yaml_suite[JS2J-First occurrence: &anchor Value\nSecond occurrence: *anchor] FAILED [ 19%]
tests/test_yaml_suite.py::test_yaml_suite[LHL4----\n!invalid{}tag scalar] FAILED [ 20%]
tests/test_yaml_suite.py::test_yaml_suite[7TMG----\n[ word1\n# comment\n, word2]] PASSED [ 20%]
tests/test_yaml_suite.py::test_yaml_suite[36F6----\nplain: a\n b\n\n c] FAILED [ 20%]
tests/test_yaml_suite.py::test_yaml_suite[U99R-- !!str, xxx] PASSED      [ 21%]
tests/test_yaml_suite.py::test_yaml_suite[RTP8-%YAML 1.2\n---\nDocument\n... # Suffix] FAILED [ 21%]
tests/test_yaml_suite.py::test_yaml_suite[LP6E-- [a, b , c ]\n- { "a"  : b\n   , c : 'd' ,\n   e   : "f"\n  }\n- [      ]] PASSED [ 21%]
tests/test_yaml_suite.py::test_yaml_suite[Q88A-- [ a, b ]\n- { a: b }\n- "a"\n- 'b'\n- c] PASSED [ 21%]
tests/test_yaml_suite.py::test_yaml_suite[QT73-# comment\n...] FAILED    [ 22%]
tests/test_yaml_suite.py::test_yaml_suite[FRK4-{\n  ? foo :,\n  : bar,\n}] FAILED [ 22%]
tests/test_yaml_suite.py::test_yaml_suite[PRH3-' 1st non-empty\n\n 2nd non-empty\u2423\n\u2014\u2014\u2014\xbb3rd non-empty '] PASSED [ 22%]
tests/test_yaml_suite.py::test_yaml_suite[Y79Y-foo: |\n\u2014\u2014\u2014\u2014\xbb\nbar: 1] PASSED [ 23%]
tests/test_yaml_suite.py::test_yaml_suite[2LFX-%FOO  bar baz # Should be ignored\n              # with a warning.\n---\n"foo"] FAILED [ 23%]
tests/test_yaml_suite.py::test_yaml_suite[PW8X-- &a\n- a\n-\n  &a : a\n  b: &b\n-\n  &c : &a\n-\n  ? &d\n-\n  ? &e\n  : &a] FAILED [ 23%]
tests/test_yaml_suite.py::test_yaml_suite[Q4CL-key1: "quoted1"\nkey2: "quoted2" trailing content\nkey3: "quoted3"] FAILED [ 23%]
tests/test_yaml_suite.py::test_yaml_suite[S4JQ-# Assuming conventional resolution:\n- "12"\n- 12\n- ! 12] FAILED [ 24%]
tests/test_yaml_suite.py::test_yaml_suite[BU8L-key: &anchor\n !!map\n  a: b] PASSED [ 24%]
tests/test_yaml_suite.py::test_yaml_suite[F3CP----\n{ a: [b, c, { d: [e, f] } ] }] PASSED [ 24%]
tests/test_yaml_suite.py::test_yaml_suite[HU3P-key:\n  word1 word2\n  no: key] FAILED [ 25%]
tests/test_yaml_suite.py::test_yaml_suite[UDR7-sequence: [ one, two, ]\nmapping: { sky: blue, sea: green }] PASSED [ 25%]
tests/test_yaml_suite.py::test_yaml_suite[X38W-{ &a [a, &b b]: *b, *a : [c, *b, d]}] PASSED [ 25%]
tests/test_yaml_suite.py::test_yaml_suite[Z67P-literal: |2\n  value\nfolded: !foo >1\n value] FAILED [ 25%]
tests/test_yaml_suite.py::test_yaml_suite[62EZ----\nx: { y: z }in: valid] PASSED [ 26%]
tests/test_yaml_suite.py::test_yaml_suite[9U5K----\n# Products purchased\n- item    : Super Hoop\n  quantity: 1\n- item    : Basketball\n  quantity: 4\n- item    : Big Shoes\n  quantity: 1] FAILED [ 26%]
tests/test_yaml_suite.py::test_yaml_suite[33X3----\n- !!int 1\n- !!int -2\n- !!int 33] FAILED [ 26%]
tests/test_yaml_suite.py::test_yaml_suite[J7VC-one: 2\n\n\nthree: 4] FAILED [ 27%]
tests/test_yaml_suite.py::test_yaml_suite[ZCZ6-a: b: c: d] PASSED        [ 27%]
tests/test_yaml_suite.py::test_yaml_suite[J9HZ----\nhr: # 1998 hr ranking\n  - Mark McGwire\n  - Sammy Sosa\nrbi:\n  # 1998 rbi ranking\n  - Sammy Sosa\n  - Ken Griffey] FAILED [ 27%]
tests/test_yaml_suite.py::test_yaml_suite[4MUZ-{"foo"\n: "bar"}] PASSED  [ 27%]
tests/test_yaml_suite.py::test_yaml_suite[UGM3---- !<tag:clarkevans.com,2002:invoice>\ninvoice: 34843\ndate   : 2001-01-23\nbill-to: &id001\n    given  : Chris\n    family : Dumars\n    address:\n        lines: |\n            458 Walkman Dr.\n            Suite #292\n        city    : Royal Oak\n        state   : MI\n        postal  : 48046\nship-to: *id001\nproduct:\n    - sku         : BL394D\n      quantity    : 4\n      description : Basketball\n      price       : 450.00\n    - sku         : BL4438H\n      quantity    : 1\n      description : Super Hoop\n      price       : 2392.00\ntax  : 251.42\ntotal: 4443.52\ncomments:\n    Late afternoon is best.\n    Backup contact is Nancy\n    Billsmer @ 338-4338.] FAILED [ 28%]
tests/test_yaml_suite.py::test_yaml_suite[55WF----\n"\\."] PASSED        [ 28%]
tests/test_yaml_suite.py::test_yaml_suite[HMK4-name: Mark McGwire\naccomplishment: >\n  Mark set a major league\n  home run record in 1998.\nstats: |\n  65 Home Runs\n  0.278 Batting Average] FAILED [ 28%]
tests/test_yaml_suite.py::test_yaml_suite[6H3V-'foo: bar\\': baz'] FAILED [ 29%]
tests/test_yaml_suite.py::test_yaml_suite[5GBF-Folding:\n  "Empty line\n   \xbb\n  as a line feed"\nChomping: |\n  Clipped empty lines\n\u2423\n\u21b5] FAILED [ 29%]
tests/test_yaml_suite.py::test_yaml_suite[D49Q-'a\\nb': 1\n'c\n d': 1] FAILED [ 29%]
tests/test_yaml_suite.py::test_yaml_suite[9MQT---- "a\n...x\nb"] PASSED  [ 29%]
tests/test_yaml_suite.py::test_yaml_suite[2G84---- |0] FAILED            [ 30%]
tests/test_yaml_suite.py::test_yaml_suite[HMQ5-!!str &a1 "foo":\n  !!str bar\n&a2 baz : *a1] FAILED [ 30%]
tests/test_yaml_suite.py::test_yaml_suite[9SHH-single: 'text'\ndouble: "text"] PASSED [ 30%]
tests/test_yaml_suite.py::test_yaml_suite[G7JE-a\\nb: 1\nc\n d: 1] FAILED [ 31%]
tests/test_yaml_suite.py::test_yaml_suite[MZX3-- plain\n- "double quoted"\n- 'single quoted'\n- >\n  block\n- plain again] FAILED [ 31%]
tests/test_yaml_suite.py::test_yaml_suite[9MMA-%YAML 1.2] PASSED         [ 31%]
tests/test_yaml_suite.py::test_yaml_suite[Q8AD----\n"folded\u2423\nto a space,\n\u2423\nto a line feed, or \xbb\\\n \\ \xbbnon-content"] FAILED [ 31%]
tests/test_yaml_suite.py::test_yaml_suite[G5U8----\n- [-, -]] FAILED     [ 32%]
tests/test_yaml_suite.py::test_yaml_suite[NB6Z-key:\n  value\n  with\n  \u2014\xbb\n  tabs] FAILED [ 32%]
tests/test_yaml_suite.py::test_yaml_suite[6PBE----\n?\n- a\n- b\n:\n- c\n- d] FAILED [ 32%]
tests/test_yaml_suite.py::test_yaml_suite[ZXT5-[ "key"\n  :value ]] FAILED [ 33%]
tests/test_yaml_suite.py::test_yaml_suite[K4SU-- foo\n- bar\n- 42] FAILED [ 33%]
tests/test_yaml_suite.py::test_yaml_suite[7BMT----\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4: &node4\n  &k4 key4: four\ntop5: &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven] FAILED [ 33%]
tests/test_yaml_suite.py::test_yaml_suite[FTA2---- &sequence\n- a] PASSED [ 33%]
tests/test_yaml_suite.py::test_yaml_suite[G4RS-unicode: "Sosa did fine.\\u263A"\ncontrol: "\\b1998\\t1999\\t2000\\n"\nhex esc: "\\x0d\\x0a is \\r\\n"\n\nsingle: '"Howdy!" he cried.'\nquoted: ' # Not a ''comment''.'\ntie-fighter: '|\\-*-/|'] FAILED [ 34%]
tests/test_yaml_suite.py::test_yaml_suite[HM87-[:x]] PASSED              [ 34%]
tests/test_yaml_suite.py::test_yaml_suite[5BVJ-literal: |\n  some\n  text\nfolded: >\n  some\n  text] FAILED [ 34%]
tests/test_yaml_suite.py::test_yaml_suite[QB6E----\nquoted: "a\nb\nc"] PASSED [ 35%]
tests/test_yaml_suite.py::test_yaml_suite[8UDB-[\n"double\n quoted", 'single\n           quoted',\nplain\n text, [ nested ],\nsingle: pair,\n]] FAILED [ 35%]
tests/test_yaml_suite.py::test_yaml_suite[52DL----\n! a] PASSED          [ 35%]
tests/test_yaml_suite.py::test_yaml_suite[4QFQ-- |\n detected\n- >\n\u2423\n\u2423\u2423\n  # detected\n- |1\n  explicit\n- >\n detected] PASSED [ 35%]
tests/test_yaml_suite.py::test_yaml_suite[Q5MG-\u2014\u2014\u2014\xbb{}] PASSED [ 36%]
tests/test_yaml_suite.py::test_yaml_suite[M7NX----\n{\n a: [\n  b, c, {\n   d: [e, f]\n  }\n ]\n}] PASSED [ 36%]
tests/test_yaml_suite.py::test_yaml_suite[6M2F-? &a a\n: &b b\n: *a] FAILED [ 36%]
tests/test_yaml_suite.py::test_yaml_suite[EW3V-k1: v1\n k2: v2] FAILED   [ 37%]
tests/test_yaml_suite.py::test_yaml_suite[LQZ7-"implicit block key" : [\n  "implicit flow key" : value,\n ]] FAILED [ 37%]
tests/test_yaml_suite.py::test_yaml_suite[6KGN----\na: &anchor\nb: *anchor] PASSED [ 37%]
tests/test_yaml_suite.py::test_yaml_suite[YJV2-[-]] FAILED               [ 37%]
tests/test_yaml_suite.py::test_yaml_suite[7T8X->\n\n folded\n line\n\n next\n line\n   * bullet\n\n   * list\n   * lines\n\n last\n line\n\n# Comment] PASSED [ 38%]
tests/test_yaml_suite.py::test_yaml_suite[9C9N----\nflow: [a,\nb,\nc]] PASSED [ 38%]
tests/test_yaml_suite.py::test_yaml_suite[Z9M4-%TAG !e! tag:example.com,2000:app/\n---\n- !e!foo "bar"] FAILED [ 38%]
tests/test_yaml_suite.py::test_yaml_suite[6JQW-# ASCII Art\n--- |\n  \\//||\\/||\n  // ||  ||__] FAILED [ 39%]
tests/test_yaml_suite.py::test_yaml_suite[RXY3----\n'\n...\n'] PASSED    [ 39%]
tests/test_yaml_suite.py::test_yaml_suite[4GC6-'here''s to "quotes"'] PASSED [ 39%]
tests/test_yaml_suite.py::test_yaml_suite[9HCY-!foo "bar"\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"] FAILED [ 39%]
tests/test_yaml_suite.py::test_yaml_suite[JHB9-# Ranking of 1998 home runs\n---\n- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n\n# Team ranking\n---\n- Chicago Cubs\n- St Louis Cardinals] FAILED [ 40%]
tests/test_yaml_suite.py::test_yaml_suite[4FJ6----\n[\n  [ a, [ [[b,c]]: d, e]]: 23\n]] FAILED [ 40%]
tests/test_yaml_suite.py::test_yaml_suite[7LBH-"a\\nb": 1\n"c\n d": 1] FAILED [ 40%]
tests/test_yaml_suite.py::test_yaml_suite[2CMS-this\n is\n  invalid: x] FAILED [ 41%]
tests/test_yaml_suite.py::test_yaml_suite[M7A3-Bare\ndocument\n...\n# No document\n...\n|\n%!PS-Adobe-2.0 # Not the first line] FAILED [ 41%]
tests/test_yaml_suite.py::test_yaml_suite[W42U-- # Empty\n- |\n block node\n- - one # Compact\n  - two # sequence\n- one: two # Compact mapping] FAILED [ 41%]
tests/test_yaml_suite.py::test_yaml_suite[236B-foo:\n  bar\ninvalid] FAILED [ 41%]
tests/test_yaml_suite.py::test_yaml_suite[F6MC----\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular] FAILED [ 42%]
tests/test_yaml_suite.py::test_yaml_suite[ZK9H-{ key: [[[\n  value\n ]]]\n}] PASSED [ 42%]
tests/test_yaml_suite.py::test_yaml_suite[9MAG----\n[ , a, b, c ]] PASSED [ 42%]
tests/test_yaml_suite.py::test_yaml_suite[JKF3-- - "bar\nbar": x] PASSED [ 43%]
tests/test_yaml_suite.py::test_yaml_suite[JR7V-- a?string\n- another ? string\n- key: value?\n- [a?string]\n- [another ? string]\n- {key: value? }\n- {key: value?}\n- {key?: value }] FAILED [ 43%]
tests/test_yaml_suite.py::test_yaml_suite[UKK6-- :] PASSED               [ 43%]
tests/test_yaml_suite.py::test_yaml_suite[FQ7F-- Mark McGwire\n- Sammy Sosa\n- Ken Griffey] FAILED [ 43%]
tests/test_yaml_suite.py::test_yaml_suite[753E---- |-\n ab\n\u2423\n\u2423\n...] PASSED [ 44%]
tests/test_yaml_suite.py::test_yaml_suite[9YRD-a\nb\u2423\u2423\n  c\nd\n\ne] FAILED [ 44%]
tests/test_yaml_suite.py::test_yaml_suite[H7TQ-%YAML 1.2 foo\n---] FAILED [ 44%]
tests/test_yaml_suite.py::test_yaml_suite[5NYZ-key:    # Comment\n  value] PASSED [ 45%]
tests/test_yaml_suite.py::test_yaml_suite[UV7Q-x:\n - x\n  \u2014\u2014\xbbx] FAILED [ 45%]
tests/test_yaml_suite.py::test_yaml_suite[V9D5-- sun: yellow\n- ? earth: blue\n  : moon: white] FAILED [ 45%]
tests/test_yaml_suite.py::test_yaml_suite[KSS4---- "quoted\nstring"\n--- &node foo] PASSED [ 45%]
tests/test_yaml_suite.py::test_yaml_suite[98YD-# Comment only.] PASSED   [ 46%]
tests/test_yaml_suite.py::test_yaml_suite[M2N8-- ? : x] PASSED           [ 46%]
tests/test_yaml_suite.py::test_yaml_suite[NHX8-:\n\u21b5\n\u21b5] FAILED [ 46%]
tests/test_yaml_suite.py::test_yaml_suite[RZT7----\nTime: 2001-11-23 15:01:42 -5\nUser: ed\nWarning:\n  This is an error message\n  for the log file\n---\nTime: 2001-11-23 15:02:31 -5\nUser: ed\nWarning:\n  A slightly different error\n  message.\n---\nDate: 2001-11-23 15:03:17 -5\nUser: ed\nFatal:\n  Unknown variable "bar"\nStack:\n  - file: TopClass.py\n    line: 23\n    code: |\n      x = MoreObject("345\\n")\n  - file: MoreClass.py\n    line: 58\n    code: |-\n      foo = bar] FAILED [ 47%]
tests/test_yaml_suite.py::test_yaml_suite[RHX7----\nkey: value\n%YAML 1.2\n---] FAILED [ 47%]
tests/test_yaml_suite.py::test_yaml_suite[9DXL-Mapping: Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20] FAILED [ 47%]
tests/test_yaml_suite.py::test_yaml_suite[T4YY----\n' 1st non-empty\n\n 2nd non-empty\u2423\n 3rd non-empty '] PASSED [ 47%]
tests/test_yaml_suite.py::test_yaml_suite[DK3J---- >\nline1\n# no comment\nline3] FAILED [ 48%]
tests/test_yaml_suite.py::test_yaml_suite[F8F9-# Strip\n # Comments:] FAILED [ 48%]
tests/test_yaml_suite.py::test_yaml_suite[TL85-"\n  foo\u2423\n\u2423\n  \u2014\xbb bar\n\n  baz\n"] PASSED [ 48%]
tests/test_yaml_suite.py::test_yaml_suite[82AN----word1\nword2] FAILED   [ 49%]
tests/test_yaml_suite.py::test_yaml_suite[5WE3-? explicit key # Empty value\n? |\n  block key\n: - one # Explicit compact\n  - two # block value] FAILED [ 49%]
tests/test_yaml_suite.py::test_yaml_suite[SBG9-{a: [b, c], [d, e]: f}] PASSED [ 49%]
tests/test_yaml_suite.py::test_yaml_suite[B63P-%YAML 1.2\n...] FAILED    [ 49%]
tests/test_yaml_suite.py::test_yaml_suite[KK5P-complex1:\n  ? - a\ncomplex2:\n  ? - a\n  : b\ncomplex3:\n  ? - a\n  : >\n    b\ncomplex4:\n  ? >\n    a\n  :\ncomplex5:\n  ? - a\n  : - b] FAILED [ 50%]
tests/test_yaml_suite.py::test_yaml_suite[HWV9-...] PASSED               [ 50%]
tests/test_yaml_suite.py::test_yaml_suite[3R3P-&sequence\n- a] PASSED    [ 50%]
tests/test_yaml_suite.py::test_yaml_suite[6VJK->\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!] FAILED [ 50%]
tests/test_yaml_suite.py::test_yaml_suite[4EJS----\na:\n\u2014\u2014\u2014\xbbb:\n\u2014\u2014\u2014\xbb\u2014\u2014\u2014\xbbc: value] PASSED [ 51%]
tests/test_yaml_suite.py::test_yaml_suite[M9B4-|\n literal\n \u2014\u2014\xbbtext\n\u21b5\n\u21b5] PASSED [ 51%]
tests/test_yaml_suite.py::test_yaml_suite[6BFJ----\n&mapping\n&key [ &item a, b, c ]: value] PASSED [ 51%]
tests/test_yaml_suite.py::test_yaml_suite[ZF4X-Mark McGwire: {hr: 65, avg: 0.278}\nSammy Sosa: {\n    hr: 63,\n    avg: 0.288\n  }] PASSED [ 52%]
tests/test_yaml_suite.py::test_yaml_suite[W9L4----\nblock scalar: |\n\u2423\u2423\u2423\u2423\u2423\n  more spaces at the beginning\n  are invalid] PASSED [ 52%]
tests/test_yaml_suite.py::test_yaml_suite[YD5X-- [name        , hr, avg  ]\n- [Mark McGwire, 65, 0.278]\n- [Sammy Sosa  , 63, 0.288]] PASSED [ 52%]
tests/test_yaml_suite.py::test_yaml_suite[F2C7-- &a !!str a\n- !!int 2\n- !!int &c 4\n- &d d] FAILED [ 52%]
tests/test_yaml_suite.py::test_yaml_suite[MJS9->\n  foo\u2423\n\u2423\n  \u2014\xbb bar\n\n  baz] PASSED [ 53%]
tests/test_yaml_suite.py::test_yaml_suite[FH7J-- !!str\n-\n  !!null : a\n  b: !!str\n- !!str : !!null] FAILED [ 53%]
tests/test_yaml_suite.py::test_yaml_suite[PBJ2-american:\n  - Boston Red Sox\n  - Detroit Tigers\n  - New York Yankees\nnational:\n  - New York Mets\n  - Chicago Cubs\n  - Atlanta Braves] FAILED [ 53%]
tests/test_yaml_suite.py::test_yaml_suite[C2SP-[23\n]: 42] PASSED        [ 54%]
tests/test_yaml_suite.py::test_yaml_suite[Y2GN----\nkey: &an:chor value] PASSED [ 54%]
tests/test_yaml_suite.py::test_yaml_suite[5LLU-block scalar: >\n\u2423\n\u2423\u2423\n\u2423\u2423\u2423\n invalid] PASSED [ 54%]
tests/test_yaml_suite.py::test_yaml_suite[CQ3W----\nkey: "missing closing quote] FAILED [ 54%]
tests/test_yaml_suite.py::test_yaml_suite[W4TN-%YAML 1.2\n--- |\n%!PS-Adobe-2.0\n...\n%YAML 1.2\n---\n# Empty\n...] FAILED [ 55%]
tests/test_yaml_suite.py::test_yaml_suite[93WF---- >-\n  trimmed\n\u2423\u2423\n\u2423\n\n  as\n  space] PASSED [ 55%]
tests/test_yaml_suite.py::test_yaml_suite[XLQ9----\nscalar\n%YAML 1.2] FAILED [ 55%]
tests/test_yaml_suite.py::test_yaml_suite[W5VH-a: &:@*!$"<foo>: scalar a\nb: *:@*!$"<foo>:] FAILED [ 56%]
tests/test_yaml_suite.py::test_yaml_suite[CXX2---- &anchor a: b] PASSED  [ 56%]
tests/test_yaml_suite.py::test_yaml_suite[U44R-map:\n  key1: "quoted1"\n   key2: "bad indentation"] FAILED [ 56%]
tests/test_yaml_suite.py::test_yaml_suite[D88J-a: [b, c]] PASSED         [ 56%]
tests/test_yaml_suite.py::test_yaml_suite[BD7L-- item1\n- item2\ninvalid: x] FAILED [ 57%]
tests/test_yaml_suite.py::test_yaml_suite[UT92----\n{ matches\n% : 20 }\n...\n---\n# Empty\n...] PASSED [ 57%]
tests/test_yaml_suite.py::test_yaml_suite[4CQQ-plain:\n  This unquoted scalar\n  spans many lines.\n\nquoted: "So does this\n  quoted scalar.\\n"] FAILED [ 57%]
tests/test_yaml_suite.py::test_yaml_suite[ZVH3-- key: value\n - item1] FAILED [ 58%]
tests/test_yaml_suite.py::test_yaml_suite[6JWB-foo: !!seq\n  - !!str a\n  - !!map\n    key: !!str value] FAILED [ 58%]
tests/test_yaml_suite.py::test_yaml_suite[9KAX----\n&a1\n!!str\nscalar1\n---\n!!str\n&a2\nscalar2\n---\n&a3\n!!str scalar3\n---\n&a4 !!map\n&a5 !!str key5: value4\n---\na6: 1\n&anchor6 b6: 2\n---\n!!map\n&a8 !!str key8: value7\n---\n!!map\n!!str &a10 key10: value9\n---\n!!str &a11\nvalue11] FAILED [ 58%]
tests/test_yaml_suite.py::test_yaml_suite[E76Z-&a a: &b b\n*b : *a] FAILED [ 58%]
tests/test_yaml_suite.py::test_yaml_suite[M6YH-- |\n x\n-\n foo: bar\n-\n - 42] FAILED [ 59%]
tests/test_yaml_suite.py::test_yaml_suite[H3Z8----\nwanted: love \u2665 and peace \u262e] PASSED [ 59%]
tests/test_yaml_suite.py::test_yaml_suite[D83L-- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent] FAILED [ 59%]
tests/test_yaml_suite.py::test_yaml_suite[GT5M-- item1\n&node\n- item2] FAILED [ 60%]
tests/test_yaml_suite.py::test_yaml_suite[M5DY-? - Detroit Tigers\n  - Chicago cubs\n:\n  - 2001-07-23\n\n? [ New York Yankees,\n    Atlanta Braves ]\n: [ 2001-07-02, 2001-08-12,\n    2001-08-14 ]] FAILED [ 60%]
tests/test_yaml_suite.py::test_yaml_suite[4UYU-"foo: bar\\": baz"] PASSED [ 60%]
tests/test_yaml_suite.py::test_yaml_suite[CC74-%TAG !e! tag:example.com,2000:app/\n---\n!e!foo "bar"] FAILED [ 60%]
tests/test_yaml_suite.py::test_yaml_suite[SU5Z-key: "value"# invalid comment] PASSED [ 61%]
tests/test_yaml_suite.py::test_yaml_suite[9SA2----\n- { "single line": value}\n- { "multi\n  line": value}] PASSED [ 61%]
tests/test_yaml_suite.py::test_yaml_suite[CTN5----\n[ a, b, c, , ]] PASSED [ 61%]
tests/test_yaml_suite.py::test_yaml_suite[A2M4-? a\n: -\xbbb\n  -  -\u2014\xbbc\n     - d] FAILED [ 62%]
tests/test_yaml_suite.py::test_yaml_suite[J5UC-foo: blue\nbar: arrr\nbaz: jazz] FAILED [ 62%]
tests/test_yaml_suite.py::test_yaml_suite[4RWC-[1, 2, 3]\u2423\u2423] PASSED [ 62%]
tests/test_yaml_suite.py::test_yaml_suite[CN3R-&flowseq [\n a: b,\n &c c: d,\n { &e e: f },\n &g { g: h }\n]] FAILED [ 62%]
tests/test_yaml_suite.py::test_yaml_suite[7MNF-top1:\n  key1: val1\ntop2] FAILED [ 63%]
tests/test_yaml_suite.py::test_yaml_suite[FBC9-safe: a!"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\n     !"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\nsafe question mark: ?foo\nsafe colon: :foo\nsafe dash: -foo] FAILED [ 63%]
tests/test_yaml_suite.py::test_yaml_suite[L9U5-implicit block key : [\n  implicit flow key : value,\n ]] FAILED [ 63%]
tests/test_yaml_suite.py::test_yaml_suite[DHP8-[foo, bar, 42]] PASSED    [ 64%]
tests/test_yaml_suite.py::test_yaml_suite[9BXH----\n- { "single line", a: b}\n- { "multi\n  line", a: b}] PASSED [ 64%]
tests/test_yaml_suite.py::test_yaml_suite[X8DW----\n? key\n# comment\n: value] FAILED [ 64%]
tests/test_yaml_suite.py::test_yaml_suite[S4GJ----\nfolded: > first line\n  second line] FAILED [ 64%]
tests/test_yaml_suite.py::test_yaml_suite[CVW2----\n[ a, b, c,#invalid\n]] PASSED [ 65%]
tests/test_yaml_suite.py::test_yaml_suite[GH63-? a\n: 1.3\nfifteen: d] FAILED [ 65%]
tests/test_yaml_suite.py::test_yaml_suite[7W2P-? a\n? b\nc:] FAILED      [ 65%]
tests/test_yaml_suite.py::test_yaml_suite[6LVF-%FOO  bar baz # Should be ignored\n              # with a warning.\n--- "foo"] FAILED [ 66%]
tests/test_yaml_suite.py::test_yaml_suite[4H7K----\n[ a, b, c ] ]] FAILED [ 66%]
tests/test_yaml_suite.py::test_yaml_suite[DBG4-# Outside flow collection:\n- ::vector\n- ": - ()"\n- Up, up, and away!\n- -123\n- http://example.com/foo#bar\n# Inside flow collection:\n- [ ::vector,\n  ": - ()",\n  "Up, up and away!",\n  -123,\n  http://example.com/foo#bar ]] FAILED [ 66%]
tests/test_yaml_suite.py::test_yaml_suite[MYW6-|-\n ab\n\u2423\n\u2423\n...] PASSED [ 66%]
tests/test_yaml_suite.py::test_yaml_suite[9JBA----\n[ a, b, c, ]#invalid] PASSED [ 67%]
tests/test_yaml_suite.py::test_yaml_suite[NKF9----\nkey: value\n: empty key\n---\n{\n key: value, : empty key\n}\n---\n# empty key and value\n:\n---\n# empty key and value\n{ : }] FAILED [ 67%]
tests/test_yaml_suite.py::test_yaml_suite[H7J7-key: &x\n!!map\n  a: b] PASSED [ 67%]
tests/test_yaml_suite.py::test_yaml_suite[A984-a: b\n c\nd:\n e\n  f] PASSED [ 68%]
tests/test_yaml_suite.py::test_yaml_suite[5TRB----\n"\n---\n"] PASSED    [ 68%]
tests/test_yaml_suite.py::test_yaml_suite[6HB6-# Leading comment line spaces are\n # neither content nor indentation.] FAILED [ 68%]
tests/test_yaml_suite.py::test_yaml_suite[U9NS----\ntime: 20:03:20\nplayer: Sammy Sosa\naction: strike (miss)\n...\n---\ntime: 20:03:47\nplayer: Sammy Sosa\naction: grand slam\n...] FAILED [ 68%]
tests/test_yaml_suite.py::test_yaml_suite[BF9H----\nplain: a\n       b # end of scalar\n       c] FAILED [ 69%]
tests/test_yaml_suite.py::test_yaml_suite[3RLN-"1 leading\n    \\ttab"] PASSED [ 69%]
tests/test_yaml_suite.py::test_yaml_suite[RR7F-a: 4.2\n? d\n: 23] FAILED [ 69%]
tests/test_yaml_suite.py::test_yaml_suite[AB8U-- single multiline\n - sequence entry] FAILED [ 70%]
tests/test_yaml_suite.py::test_yaml_suite[SF5V-%YAML 1.2\n%YAML 1.2\n---] FAILED [ 70%]
tests/test_yaml_suite.py::test_yaml_suite[565N-canonical: !!binary "\\\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\\\n OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+\\\n +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC\\\n AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs="\ngeneric: !!binary |\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\n OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+\n +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC\n AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=\ndescription:\n The binary value above is a tiny arrow encoded as a gif image.] FAILED [ 70%]
tests/test_yaml_suite.py::test_yaml_suite[R4YG-- |\n detected\n- >\n\u2423\n\u2423\u2423\n  # detected\n- |1\n  explicit\n- >\n \u2014\u2014\xbb\n detected] PASSED [ 70%]
tests/test_yaml_suite.py::test_yaml_suite[87E4-'implicit block key' : [\n  'implicit flow key' : value,\n ]] FAILED [ 71%]
tests/test_yaml_suite.py::test_yaml_suite[4HVU-key:\n   - ok\n   - also ok\n  - wrong] FAILED [ 71%]
tests/test_yaml_suite.py::test_yaml_suite[6SLA-"foo\\nbar:baz\\tx \\\\$%^&*()x": 23\n'x\\ny:z\\tx $%^&*()x': 24] FAILED [ 71%]
tests/test_yaml_suite.py::test_yaml_suite[SYW4-hr:  65    # Home runs\navg: 0.278 # Batting average\nrbi: 147   # Runs Batted In] FAILED [ 72%]
tests/test_yaml_suite.py::test_yaml_suite[MXS3-- {a: b}] PASSED          [ 72%]
tests/test_yaml_suite.py::test_yaml_suite[3MYT----\nk:#foo\n &a !t s] PASSED [ 72%]
tests/test_yaml_suite.py::test_yaml_suite[JY7Z-key1: "quoted1"\nkey2: "quoted2" no key: nor value\nkey3: "quoted3"] FAILED [ 72%]
tests/test_yaml_suite.py::test_yaml_suite[EB22----\nscalar1 # comment\n%YAML 1.2\n---\nscalar2] FAILED [ 73%]
tests/test_yaml_suite.py::test_yaml_suite[AZW3-- bla"keks: foo\n- bla]keks: foo] FAILED [ 73%]
tests/test_yaml_suite.py::test_yaml_suite[H2RW-foo: 1\n\nbar: 2\n\u2423\u2423\u2423\u2423\ntext: |\n  a\n\u2423\u2423\u2423\u2423\n  b\n\n  c\n\u2423\n  d] FAILED [ 73%]
tests/test_yaml_suite.py::test_yaml_suite[4ABK-{\nunquoted : "separate",\nhttp://foo.com,\nomitted value:,\n}] PASSED [ 74%]
tests/test_yaml_suite.py::test_yaml_suite[TD5N-- item1\n- item2\ninvalid] FAILED [ 74%]
tests/test_yaml_suite.py::test_yaml_suite[CML9-key: [ word1\n#  xxx\n  word2 ]] PASSED [ 74%]
tests/test_yaml_suite.py::test_yaml_suite[6JTT----\n[ [ a, b, c ]] FAILED [ 74%]
tests/test_yaml_suite.py::test_yaml_suite[M29M-a: |\n ab\n\u2423\n cd\n ef\n\u2423\n\n...] PASSED [ 75%]
tests/test_yaml_suite.py::test_yaml_suite[2AUY-- !!str a\n- b\n- !!int 42\n- d] FAILED [ 75%]
tests/test_yaml_suite.py::test_yaml_suite[EX5H----\na\nb\u2423\u2423\n  c\nd\n\ne] FAILED [ 75%]
tests/test_yaml_suite.py::test_yaml_suite[229Q--\n  name: Mark McGwire\n  hr:   65\n  avg:  0.278\n-\n  name: Sammy Sosa\n  hr:   63\n  avg:  0.288] FAILED [ 76%]
tests/test_yaml_suite.py::test_yaml_suite[93JH-- key: value\n  key2: value2\n-\n  key3: value3] FAILED [ 76%]
tests/test_yaml_suite.py::test_yaml_suite[FUP4-[a, [b, c]]] PASSED       [ 76%]
tests/test_yaml_suite.py::test_yaml_suite[CPZ3----\ntab: "\\tstring"] PASSED [ 76%]
tests/test_yaml_suite.py::test_yaml_suite[2JQS-: a\n: b] FAILED          [ 77%]
tests/test_yaml_suite.py::test_yaml_suite[S9E8-sequence:\n- one\n- two\nmapping:\n  ? sky\n  : blue\n  sea : green] FAILED [ 77%]
tests/test_yaml_suite.py::test_yaml_suite[5T43-- { "key":value }\n- { "key"::value }] FAILED [ 77%]
tests/test_yaml_suite.py::test_yaml_suite[GDY7-key: value\nthis is #not a: key] FAILED [ 78%]
tests/test_yaml_suite.py::test_yaml_suite[QF4Y-[\nfoo: bar\n]] FAILED    [ 78%]
tests/test_yaml_suite.py::test_yaml_suite[EXG3----\n---word1\nword2] FAILED [ 78%]
tests/test_yaml_suite.py::test_yaml_suite[DK4H----\n[ key\n  : value ]] FAILED [ 78%]
tests/test_yaml_suite.py::test_yaml_suite[N782-[\n--- ,\n...\n]] FAILED  [ 79%]
tests/test_yaml_suite.py::test_yaml_suite[VJP3-k: {\nk\n:\nv\n}] PASSED  [ 79%]
tests/test_yaml_suite.py::test_yaml_suite[BEC7-%YAML 1.3 # Attempt parsing\n          # with a warning\n---\n"foo"] FAILED [ 79%]
tests/test_yaml_suite.py::test_yaml_suite[NAT4----\na: '\n  '\nb: '\u2423\u2423\n  '\nc: "\n  "\nd: "\u2423\u2423\n  "\ne: '\n\n  '\nf: "\n\n  "\ng: '\n\n\n  '\nh: "\n\n\n  "] FAILED [ 80%]
tests/test_yaml_suite.py::test_yaml_suite[NJ66----\n- { single line: value}\n- { multi\n  line: value}] PASSED [ 80%]
tests/test_yaml_suite.py::test_yaml_suite[MUS6-%YAML 1.1#...\n---] FAILED [ 80%]
tests/test_yaml_suite.py::test_yaml_suite[SR86-key1: &a value\nkey2: &b *a] FAILED [ 80%]
tests/test_yaml_suite.py::test_yaml_suite[7A4E-" 1st non-empty\n\n 2nd non-empty\u2423\n\u2014\u2014\u2014\xbb3rd non-empty "] PASSED [ 81%]
tests/test_yaml_suite.py::test_yaml_suite[K527->-\n  trimmed\n\u2423\u2423\n\u2423\n\n  as\n  space] PASSED [ 81%]
tests/test_yaml_suite.py::test_yaml_suite[9FMG-a:\n  b:\n    c: d\n  e:\n    f: g\nh: i] FAILED [ 81%]
tests/test_yaml_suite.py::test_yaml_suite[DFF7-{\n? explicit: entry,\nimplicit: entry,\n?\n}] PASSED [ 82%]
tests/test_yaml_suite.py::test_yaml_suite[SY6V-&anchor - sequence entry] PASSED [ 82%]
tests/test_yaml_suite.py::test_yaml_suite[LX3P-[flow]: block] PASSED     [ 82%]
tests/test_yaml_suite.py::test_yaml_suite[KS4U----\n[\nsequence item\n]\ninvalid item] PASSED [ 82%]
tests/test_yaml_suite.py::test_yaml_suite[P2AD-- | # Empty header\u2193\n literal\n- >1 # Indentation indicator\u2193\n  folded\n- |+ # Chomping indicator\u2193\n keep\n\n- >1- # Both indicators\u2193\n  strip] FAILED [ 83%]
tests/test_yaml_suite.py::test_yaml_suite[735Y--\n  "flow in block"\n- >\n Block scalar\n- !!map # Block collection\n  foo : bar] FAILED [ 83%]
tests/test_yaml_suite.py::test_yaml_suite[JQ4R-block sequence:\n  - one\n  - two : three] FAILED [ 83%]
tests/test_yaml_suite.py::test_yaml_suite[CT4Q-[\n? foo\n bar : baz\n]] FAILED [ 84%]
tests/test_yaml_suite.py::test_yaml_suite[N4JP-map:\n  key1: "quoted1"\n key2: "bad indentation"] PASSED [ 84%]
tests/test_yaml_suite.py::test_yaml_suite[7BUB----\nhr:\n  - Mark McGwire\n  # Following node labeled SS\n  - &SS Sammy Sosa\nrbi:\n  - *SS # Subsequent occurrence\n  - Ken Griffey] FAILED [ 84%]
tests/test_yaml_suite.py::test_yaml_suite[XV9V-Folding:\n  "Empty line\n\n  as a line feed"\nChomping: |\n  Clipped empty lines\n\u2423\n\u21b5] FAILED [ 84%]
tests/test_yaml_suite.py::test_yaml_suite[8XDJ-key: word1\n#  xxx\n  word2] FAILED [ 85%]
tests/test_yaml_suite.py::test_yaml_suite[HS5T-1st non-empty\n\n 2nd non-empty\u2423\n\u2014\u2014\u2014\xbb3rd non-empty] FAILED [ 85%]
tests/test_yaml_suite.py::test_yaml_suite[96L6---- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury.] FAILED [ 85%]
tests/test_yaml_suite.py::test_yaml_suite[6FWR---- |+\n ab\n\u2423\n\u2423\u2423\n...] PASSED [ 86%]
tests/test_yaml_suite.py::test_yaml_suite[9TFX----\n" 1st non-empty\n\n 2nd non-empty\u2423\n 3rd non-empty "] PASSED [ 86%]
tests/test_yaml_suite.py::test_yaml_suite[7Z25----\nscalar1\n...\nkey: value] FAILED [ 86%]
tests/test_yaml_suite.py::test_yaml_suite[S98Z-empty block scalar: >\n\u2423\n\u2423\u2423\n\u2423\u2423\u2423\n # comment] PASSED [ 86%]
tests/test_yaml_suite.py::test_yaml_suite[KMK3-foo:\n  bar: 1\nbaz: 2] FAILED [ 87%]
tests/test_yaml_suite.py::test_yaml_suite[5C5M-- { one : two , three: four , }\n- {five: six,seven : eight}] PASSED [ 87%]
tests/test_yaml_suite.py::test_yaml_suite[8KB6----\n- { single line, a: b}\n- { multi\n  line, a: b}] PASSED [ 87%]
tests/test_yaml_suite.py::test_yaml_suite[T26H---- |\n\u2423\n\u2423\u2423\n  literal\n\u2423\u2423\u2423\n\u2423\u2423\n  text\n\n # Comment] PASSED [ 88%]
tests/test_yaml_suite.py::test_yaml_suite[CFD4-- [ : empty key ]\n- [: another empty key]] FAILED [ 88%]
tests/test_yaml_suite.py::test_yaml_suite[DE56-"1 trailing\\t\n    tab"] PASSED [ 88%]
tests/test_yaml_suite.py::test_yaml_suite[5KJE-- [ one, two, ]\n- [three ,four]] PASSED [ 88%]
tests/test_yaml_suite.py::test_yaml_suite[8G76-# Comment] PASSED         [ 89%]
tests/test_yaml_suite.py::test_yaml_suite[9MMW-- [ YAML : separate ]\n- [ "JSON like":adjacent ]\n- [ {JSON: like}:adjacent ]] FAILED [ 89%]
tests/test_yaml_suite.py::test_yaml_suite[PUW8----\na: b\n---] FAILED    [ 89%]
tests/test_yaml_suite.py::test_yaml_suite[RLU9-foo:\n- 42\nbar:\n  - 44] FAILED [ 90%]
tests/test_yaml_suite.py::test_yaml_suite[P76L-%TAG !! tag:example.com,2000:app/\n---\n!!int 1 - 3 # Interval, not integer] FAILED [ 90%]
tests/test_yaml_suite.py::test_yaml_suite[6CK3-%TAG !e! tag:example.com,2000:app/\n---\n- !local foo\n- !!str bar\n- !e!tag%21 baz] FAILED [ 90%]
tests/test_yaml_suite.py::test_yaml_suite[2SXE-&a: key: &a value\nfoo:\n  *a:] FAILED [ 90%]
tests/test_yaml_suite.py::test_yaml_suite[2EBW-a!"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~: safe\n?foo: safe question mark\n:foo: safe colon\n-foo: safe dash\nthis is#not: a comment] FAILED [ 91%]
tests/test_yaml_suite.py::test_yaml_suite[U3C3-%TAG !yaml! tag:yaml.org,2002:\n---\n!yaml!str "foo"] PASSED [ 91%]
tests/test_yaml_suite.py::test_yaml_suite[4ZYM-plain: text\n  lines\nquoted: "text\n  \u2014\xbblines"\nblock: |\n  text\n   \xbblines] FAILED [ 91%]
tests/test_yaml_suite.py::test_yaml_suite[SU74-key1: &alias value1\n&b *alias : value2] FAILED [ 92%]
tests/test_yaml_suite.py::test_yaml_suite[J7PZ-# The !!omap tag is one of the optional types\n# introduced for YAML 1.1. In 1.2, it is not\n# part of the standard tags and should not be\n# enabled by default.\n# Ordered maps are represented as\n# A sequence of mappings, with\n# each mapping having one key\n--- !!omap\n- Mark McGwire: 65\n- Sammy Sosa: 63\n- Ken Griffy: 58] FAILED [ 92%]
tests/test_yaml_suite.py::test_yaml_suite[S4T7-aaa: bbb\n...] FAILED     [ 92%]
tests/test_yaml_suite.py::test_yaml_suite[ZYU8-%YAML1.1\n---] FAILED     [ 92%]
tests/test_yaml_suite.py::test_yaml_suite[7FWL-!<tag:yaml.org,2002:str> foo :\n  !<!bar> baz] FAILED [ 93%]
tests/test_yaml_suite.py::test_yaml_suite[6CA3-\u2014\u2014\u2014\u2014\xbb[\n\u2014\u2014\u2014\u2014\xbb]] PASSED [ 93%]
tests/test_yaml_suite.py::test_yaml_suite[9KBC---- key1: value1\n    key2: value2] FAILED [ 93%]
tests/test_yaml_suite.py::test_yaml_suite[T833----\n{\n foo: 1\n bar: 2 }] FAILED [ 94%]
tests/test_yaml_suite.py::test_yaml_suite[7ZZ5----\nnested sequences:\n- - - []\n- - - {}\nkey1: []\nkey2: {}] FAILED [ 94%]
tests/test_yaml_suite.py::test_yaml_suite[U3XV----\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4:\n  &node4\n  &k4 key4: four\ntop5:\n  &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven] FAILED [ 94%]
tests/test_yaml_suite.py::test_yaml_suite[FP8R---- >\nline1\nline2\nline3] FAILED [ 94%]
tests/test_yaml_suite.py::test_yaml_suite[UDM2-- { url: http://example.org }] PASSED [ 95%]
tests/test_yaml_suite.py::test_yaml_suite[26DV-"top1" :\u2423\n  "key1" : &alias1 scalar1\n'top2' :\u2423\n  'key2' : &alias2 scalar2\ntop3: &node3\u2423\n  *alias1 : scalar3\ntop4:\u2423\n  *alias2 : scalar4\ntop5   :\u2423\u2423\u2423\u2423\n  scalar5\ntop6:\u2423\n  &anchor6 'key6' : scalar6] PASSED [ 95%]
tests/test_yaml_suite.py::test_yaml_suite[35KP---- !!map\n? a\n: b\n--- !!seq\n- !!str c\n--- !!str\nd\ne] FAILED [ 95%]
tests/test_yaml_suite.py::test_yaml_suite[S7BG----\n- :,] PASSED         [ 96%]
tests/test_yaml_suite.py::test_yaml_suite[S3PD-plain key: in-line value\n: # Both empty\n"quoted key":\n- entry] FAILED [ 96%]
tests/test_yaml_suite.py::test_yaml_suite[DK95-foo:\n \u2014\u2014\u2014\xbbbar] FAILED [ 96%]
tests/test_yaml_suite.py::test_yaml_suite[D9TU-foo: bar] PASSED          [ 96%]
tests/test_yaml_suite.py::test_yaml_suite[QLJ7-%TAG !prefix! tag:example.com,2011:\n--- !prefix!A\na: b\n--- !prefix!B\nc: d\n--- !prefix!C\ne: f] FAILED [ 97%]
tests/test_yaml_suite.py::test_yaml_suite[X4QW-block: ># comment\n  scalar] FAILED [ 97%]
tests/test_yaml_suite.py::test_yaml_suite[XW4D-a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne:\n &node # lala\n - x: y\nblock: > # lala\n  abcde] FAILED [ 97%]
tests/test_yaml_suite.py::test_yaml_suite[5TYM-%TAG !m! !my-\n--- # Bulb here\n!m!light fluorescent\n...\n%TAG !m! !my-\n--- # Color here\n!m!light green] FAILED [ 98%]
tests/test_yaml_suite.py::test_yaml_suite[65WH-- foo] PASSED             [ 98%]
tests/test_yaml_suite.py::test_yaml_suite[2XXW-# Sets are represented as a\n# Mapping where each key is\n# associated with a null value\n--- !!set\n? Mark McGwire\n? Sammy Sosa\n? Ken Griff] FAILED [ 98%]
tests/test_yaml_suite.py::test_yaml_suite[C4HZ-%TAG ! tag:clarkevans.com,2002:\n--- !shape\n  # Use the ! handle for presenting\n  # tag:clarkevans.com,2002:circle\n- !circle\n  center: &ORIGIN {x: 73, y: 129}\n  radius: 7\n- !line\n  start: *ORIGIN\n  finish: { x: 89, y: 102 }\n- !label\n  start: *ORIGIN\n  color: 0xFFEEBB\n  text: Pretty vector drawing.] FAILED [ 98%]
tests/test_yaml_suite.py::test_yaml_suite[6WPF----\n"\n  foo\u2423\n\u2423\n    bar\n\n  baz\n"] PASSED [ 99%]
tests/test_yaml_suite.py::test_yaml_suite[4Q9F---- >\n ab\n cd\n\u2423\n ef\n\n\n gh] PASSED [ 99%]
tests/test_yaml_suite.py::test_yaml_suite[J3BT-# Tabs and spaces\nquoted: "Quoted \u2014\u2014\u2014\xbb"\nblock:\u2014\xbb|\n  void main() {\n  \u2014\xbbprintf("Hello, world!\\n");\n  }] FAILED [ 99%]
tests/test_yaml_suite.py::test_yaml_suite[DC7X-a: b\u2014\u2014\u2014\xbb\nseq:\u2014\u2014\u2014\xbb\n - a\u2014\u2014\u2014\xbb\nc: d\u2014\u2014\u2014\xbb#X] PASSED [100%]

=================================== FAILURES ===================================
__ test_yaml_suite[M5C3-literal: |2\n  value\nfolded:\n   !foo\n  >1\n value] __

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'literal: |2\n  value\nfolded:\n   !foo\n  >1\n value'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557225.670185306, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = 'literal: |2\n  value\nfolded:\n   !foo\n  >1\n value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'literal: |2\n  value\nfolded:\n   !foo\n  >1\n value'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = 'M5C3'
yaml_content = 'literal: |2\n  value\nfolded:\n   !foo\n  >1\n value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'literal: |2\n  value\nfolded:\n   !foo\n  >1\n value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'M5C3'
yaml_content = 'literal: |2\n  value\nfolded:\n   !foo\n  >1\n value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test M5C3: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
______________ test_yaml_suite[3HFZ----\nkey: value\n... invalid] ______________

source = '---\nkey: value\n... invalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nkey: value\n... invalid'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '3HFZ', yaml_content = '---\nkey: value\n... invalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nkey: value\n... invalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '3HFZ', yaml_content = '---\nkey: value\n... invalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 3HFZ: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[57H4-sequence: !!seq\n- entry\n- !!seq\n - nested\nmapping: !!map\n foo: bar] _

source = 'sequence: !!seq\n- entry\n- !!seq\n - nested\nmapping: !!map\n foo: bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'sequence: !!seq\n- entry\n- !!seq\n - nested\nmapping: !!map\n foo: bar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '57H4'
yaml_content = 'sequence: !!seq\n- entry\n- !!seq\n - nested\nmapping: !!map\n foo: bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'sequence: !!seq\n- entry\n- !!seq\n - nested\nmapping: !!map\n foo: bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '57H4'
yaml_content = 'sequence: !!seq\n- entry\n- !!seq\n - nested\nmapping: !!map\n foo: bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 57H4: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
__ test_yaml_suite[A6F9-strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text] __

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557230.761940209, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = 'strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = 'A6F9'
yaml_content = 'strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'A6F9'
yaml_content = 'strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test A6F9: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[K3WX----\n{ "foo" # comment\n  :bar }] ____________

source = '---\n{ "foo" # comment\n  :bar }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n{ "foo" # comment\n  :bar }'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'K3WX', yaml_content = '---\n{ "foo" # comment\n  :bar }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n{ "foo" # comment\n  :bar }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'K3WX', yaml_content = '---\n{ "foo" # comment\n  :bar }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test K3WX: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[DMG6-key:\n  ok: 1\n wrong: 2] ________________

source = 'key:\n  ok: 1\n wrong: 2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key:\n  ok: 1\n wrong: 2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DMG6', yaml_content = 'key:\n  ok: 1\n wrong: 2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key:\n  ok: 1\n wrong: 2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DMG6', yaml_content = 'key:\n  ok: 1\n wrong: 2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test DMG6: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[SKE5----\nseq:\n &anchor\n- a\n- b] ______________

source = '---\nseq:\n &anchor\n- a\n- b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nseq:\n &anchor\n- a\n- b'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SKE5', yaml_content = '---\nseq:\n &anchor\n- a\n- b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nseq:\n &anchor\n- a\n- b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SKE5', yaml_content = '---\nseq:\n &anchor\n- a\n- b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test SKE5: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
____________________ test_yaml_suite[ZH7C-&a a: b\nc: &d d] ____________________

source = '&a a: b\nc: &d d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '&a a: b\nc: &d d'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZH7C', yaml_content = '&a a: b\nc: &d d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '&a a: b\nc: &d d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZH7C', yaml_content = '&a a: b\nc: &d d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test ZH7C: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________ test_yaml_suite[9CWY-key:\n - item1\n - item2\ninvalid] ____________

source = 'key:\n - item1\n - item2\ninvalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key:\n - item1\n - item2\ninvalid'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9CWY', yaml_content = 'key:\n - item1\n - item2\ninvalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key:\n - item1\n - item2\ninvalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9CWY', yaml_content = 'key:\n - item1\n - item2\ninvalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9CWY: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[96NN-foo: |-\n \u2014\u2014\xbbbar] ______________

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo: |-\n â€”â€”Â»bar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557235.873264907, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = 'foo: |-\n â€”â€”Â»bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo: |-\n â€”â€”Â»bar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = '96NN', yaml_content = 'foo: |-\n â€”â€”Â»bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'foo: |-\n â€”â€”Â»bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '96NN', yaml_content = 'foo: |-\n â€”â€”Â»bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 96NN: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
______________ test_yaml_suite[G9HC----\nseq:\n&anchor\n- a\n- b] ______________

source = '---\nseq:\n&anchor\n- a\n- b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nseq:\n&anchor\n- a\n- b'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'G9HC', yaml_content = '---\nseq:\n&anchor\n- a\n- b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nseq:\n&anchor\n- a\n- b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'G9HC', yaml_content = '---\nseq:\n&anchor\n- a\n- b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test G9HC: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[P94K-key:    # Comment\n        # lines\n  value\n\u21b5\n\u21b5] _

source = 'key:    # Comment\n        # lines\n  value\nâ†µ\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key:    # Comment\n        # lines\n  value\nâ†µ\nâ†µ'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'P94K'
yaml_content = 'key:    # Comment\n        # lines\n  value\nâ†µ\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key:    # Comment\n        # lines\n  value\nâ†µ\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'P94K'
yaml_content = 'key:    # Comment\n        # lines\n  value\nâ†µ\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test P94K: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[C2DT-{\n"adjacent":value,\n"readable": value,\n"empty":\n}] __

source = '{\n"adjacent":value,\n"readable": value,\n"empty":\n}'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '{\n"adjacent":value,\n"readable": value,\n"empty":\n}'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'C2DT'
yaml_content = '{\n"adjacent":value,\n"readable": value,\n"empty":\n}'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '{\n"adjacent":value,\n"readable": value,\n"empty":\n}'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'C2DT'
yaml_content = '{\n"adjacent":value,\n"readable": value,\n"empty":\n}'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test C2DT: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[3GZX-First occurrence: &anchor Foo\nSecond occurrence: *anchor\nOverride anchor: &anchor Bar\nReuse anchor: *anchor] _

source = 'First occurrence: &anchor Foo\nSecond occurrence: *anchor\nOverride anchor: &anchor Bar\nReuse anchor: *anchor'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'First occurrence: &anchor Foo\nSecond occurrence: *anchor\nOverride anchor: &anchor Bar\nReuse anchor: *anchor'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '3GZX'
yaml_content = 'First occurrence: &anchor Foo\nSecond occurrence: *anchor\nOverride anchor: &anchor Bar\nReuse anchor: *anchor'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'First occurrence: &anchor Foo\nSecond occurrence: *anchor\nOverride anchor: &anchor Bar\nReuse anchor: *anchor'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '3GZX'
yaml_content = 'First occurrence: &anchor Foo\nSecond occurrence: *anchor\nOverride anchor: &anchor Bar\nReuse anchor: *anchor'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 3GZX: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[V55R-- &a a\n- &b b\n- *a\n- *b] _______________

source = '- &a a\n- &b b\n- *a\n- *b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- &a a\n- &b b\n- *a\n- *b'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'V55R', yaml_content = '- &a a\n- &b b\n- *a\n- *b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- &a a\n- &b b\n- *a\n- *b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'V55R', yaml_content = '- &a a\n- &b b\n- *a\n- *b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test V55R: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
__________________ test_yaml_suite[27NA-%YAML 1.2\n--- text] ___________________

source = '%YAML 1.2\n--- text'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML 1.2\n--- text'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '27NA', yaml_content = '%YAML 1.2\n--- text'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML 1.2\n--- text'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '27NA', yaml_content = '%YAML 1.2\n--- text'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 27NA: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[Q9WF-{ first: Sammy, last: Sosa }:\n# Statistics:\n  hr:  # Home runs\n     65\n  avg: # Average\n   0.278] _

source = '{ first: Sammy, last: Sosa }:\n# Statistics:\n  hr:  # Home runs\n     65\n  avg: # Average\n   0.278'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '{ first: Sammy, last: Sosa }:\n# Statistics:\n  hr:  # Home runs\n     65\n  avg: # Average\n   0.278'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Q9WF'
yaml_content = '{ first: Sammy, last: Sosa }:\n# Statistics:\n  hr:  # Home runs\n     65\n  avg: # Average\n   0.278'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '{ first: Sammy, last: Sosa }:\n# Statistics:\n  hr:  # Home runs\n     65\n  avg: # Average\n   0.278'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Q9WF'
yaml_content = '{ first: Sammy, last: Sosa }:\n# Statistics:\n  hr:  # Home runs\n     65\n  avg: # Average\n   0.278'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test Q9WF: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[NP9H-"folded\u2423\nto a space,\xbb\n\u2423\nto a line feed, or \xbb\\\n \\ \xbbnon-content"] _

source = '"foldedâ£\nto a space,Â»\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '"foldedâ£\nto a space,Â»\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NP9H'
yaml_content = '"foldedâ£\nto a space,Â»\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '"foldedâ£\nto a space,Â»\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NP9H'
yaml_content = '"foldedâ£\nto a space,Â»\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test NP9H: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[4JVG-top1: &node1\n  &k1 key1: val1\ntop2: &node2\n  &v2 val2] _

source = 'top1: &node1\n  &k1 key1: val1\ntop2: &node2\n  &v2 val2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'top1: &node1\n  &k1 key1: val1\ntop2: &node2\n  &v2 val2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '4JVG'
yaml_content = 'top1: &node1\n  &k1 key1: val1\ntop2: &node2\n  &v2 val2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'top1: &node1\n  &k1 key1: val1\ntop2: &node2\n  &v2 val2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '4JVG'
yaml_content = 'top1: &node1\n  &k1 key1: val1\ntop2: &node2\n  &v2 val2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 4JVG: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[BS4K-word1  # comment\nword2] _________________

source = 'word1  # comment\nword2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'word1  # comment\nword2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'BS4K', yaml_content = 'word1  # comment\nword2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'word1  # comment\nword2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'BS4K', yaml_content = 'word1  # comment\nword2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test BS4K: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
________ test_yaml_suite[K858-strip: >-\n\nclip: >\n\nkeep: |+\n\u21b5] ________

source = 'strip: >-\n\nclip: >\n\nkeep: |+\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'strip: >-\n\nclip: >\n\nkeep: |+\nâ†µ'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 6: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'K858', yaml_content = 'strip: >-\n\nclip: >\n\nkeep: |+\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'strip: >-\n\nclip: >\n\nkeep: |+\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 6: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'K858', yaml_content = 'strip: >-\n\nclip: >\n\nkeep: |+\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test K858: Parser error: Parser error: Parse error at line 6: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[9WXW-# Private\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"] _

source = '# Private\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Private\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9WXW'
yaml_content = '# Private\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Private\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9WXW'
yaml_content = '# Private\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9WXW: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[5U3A-key: - a\n     - b] ___________________

source = 'key: - a\n     - b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key: - a\n     - b'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '5U3A', yaml_content = 'key: - a\n     - b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key: - a\n     - b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '5U3A', yaml_content = 'key: - a\n     - b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 5U3A: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[6ZKB-Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20] _

source = 'Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6ZKB'
yaml_content = 'Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6ZKB'
yaml_content = 'Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6ZKB: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_________ test_yaml_suite[L94M-? !!str a\n: !!int 47\n? c\n: !!str d] __________

source = '? !!str a\n: !!int 47\n? c\n: !!str d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '? !!str a\n: !!int 47\n? c\n: !!str d'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'L94M', yaml_content = '? !!str a\n: !!int 47\n? c\n: !!str d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '? !!str a\n: !!int 47\n? c\n: !!str d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'L94M', yaml_content = '? !!str a\n: !!int 47\n? c\n: !!str d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test L94M: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[3ALJ-- - s1_i1\n  - s1_i2\n- s2] _______________

source = '- - s1_i1\n  - s1_i2\n- s2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- - s1_i1\n  - s1_i2\n- s2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '3ALJ', yaml_content = '- - s1_i1\n  - s1_i2\n- s2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- - s1_i1\n  - s1_i2\n- s2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '3ALJ', yaml_content = '- - s1_i1\n  - s1_i2\n- s2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 3ALJ: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_________ test_yaml_suite[4WA9-- aaa: |2\n    xxx\n  bbb: |\n    xxx] __________

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- aaa: |2\n    xxx\n  bbb: |\n    xxx'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557241.175378136, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = '- aaa: |2\n    xxx\n  bbb: |\n    xxx'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- aaa: |2\n    xxx\n  bbb: |\n    xxx'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = '4WA9', yaml_content = '- aaa: |2\n    xxx\n  bbb: |\n    xxx'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- aaa: |2\n    xxx\n  bbb: |\n    xxx'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '4WA9', yaml_content = '- aaa: |2\n    xxx\n  bbb: |\n    xxx'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 4WA9: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
_____ test_yaml_suite[CUP7-anchored: !local &anchor value\nalias: *anchor] _____

source = 'anchored: !local &anchor value\nalias: *anchor'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'anchored: !local &anchor value\nalias: *anchor'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CUP7'
yaml_content = 'anchored: !local &anchor value\nalias: *anchor'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'anchored: !local &anchor value\nalias: *anchor'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CUP7'
yaml_content = 'anchored: !local &anchor value\nalias: *anchor'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test CUP7: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[8QBE-key:\n - item1\n - item2] ________________

source = 'key:\n - item1\n - item2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key:\n - item1\n - item2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '8QBE', yaml_content = 'key:\n - item1\n - item2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key:\n - item1\n - item2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '8QBE', yaml_content = 'key:\n - item1\n - item2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 8QBE: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_________________ test_yaml_suite[5MUD----\n{ "foo"\n  :bar }] _________________

source = '---\n{ "foo"\n  :bar }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n{ "foo"\n  :bar }'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '5MUD', yaml_content = '---\n{ "foo"\n  :bar }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n{ "foo"\n  :bar }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '5MUD', yaml_content = '---\n{ "foo"\n  :bar }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 5MUD: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
______________ test_yaml_suite[ZWK4----\na: 1\n? b\n&anchor c: 3] ______________

source = '---\na: 1\n? b\n&anchor c: 3'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\na: 1\n? b\n&anchor c: 3'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZWK4', yaml_content = '---\na: 1\n? b\n&anchor c: 3'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\na: 1\n? b\n&anchor c: 3'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZWK4', yaml_content = '---\na: 1\n? b\n&anchor c: 3'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test ZWK4: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[6S55-key:\n - bar\n - baz\n invalid] _____________

source = 'key:\n - bar\n - baz\n invalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key:\n - bar\n - baz\n invalid'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6S55', yaml_content = 'key:\n - bar\n - baz\n invalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key:\n - bar\n - baz\n invalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6S55', yaml_content = 'key:\n - bar\n - baz\n invalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6S55: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[RZP5-a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne: &node # lala\n - x: y\nblock: > # lala\n  abcde] _

source = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne: &node # lala\n - x: y\nblock: > # lala\n  abcde'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne: &node # lala\n - x: y\nblock: > # lala\n  abcde'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 7: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RZP5'
yaml_content = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne: &node # lala\n - x: y\nblock: > # lala\n  abcde'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne: &node # lala\n - x: y\nblock: > # lala\n  abcde'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 7: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RZP5'
yaml_content = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne: &node # lala\n - x: y\nblock: > # lala\n  abcde'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test RZP5: Parser error: Parser error: Parse error at line 7: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[6WLZ-# Private\n---\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"] _

source = '# Private\n---\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Private\n---\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6WLZ'
yaml_content = '# Private\n---\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Private\n---\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6WLZ'
yaml_content = '# Private\n---\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6WLZ: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_________ test_yaml_suite[L383---- foo  # comment\n--- foo  # comment] _________

source = '--- foo  # comment\n--- foo  # comment'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '--- foo  # comment\n--- foo  # comment'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'L383', yaml_content = '--- foo  # comment\n--- foo  # comment'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '--- foo  # comment\n--- foo  # comment'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'L383', yaml_content = '--- foo  # comment\n--- foo  # comment'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test L383: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[AZ63-one:\n- 2\n- 3\nfour: 5] _________________

source = 'one:\n- 2\n- 3\nfour: 5'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'one:\n- 2\n- 3\nfour: 5'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'AZ63', yaml_content = 'one:\n- 2\n- 3\nfour: 5'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'one:\n- 2\n- 3\nfour: 5'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'AZ63', yaml_content = 'one:\n- 2\n- 3\nfour: 5'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test AZ63: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[74H7-!!str a: b\nc: !!int 42\ne: !!str f\ng: h\n!!str 23: !!bool false] _

source = '!!str a: b\nc: !!int 42\ne: !!str f\ng: h\n!!str 23: !!bool false'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '!!str a: b\nc: !!int 42\ne: !!str f\ng: h\n!!str 23: !!bool false'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '74H7'
yaml_content = '!!str a: b\nc: !!int 42\ne: !!str f\ng: h\n!!str 23: !!bool false'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '!!str a: b\nc: !!int 42\ne: !!str f\ng: h\n!!str 23: !!bool false'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '74H7'
yaml_content = '!!str a: b\nc: !!int 42\ne: !!str f\ng: h\n!!str 23: !!bool false'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 74H7: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[JS2J-First occurrence: &anchor Value\nSecond occurrence: *anchor] _

source = 'First occurrence: &anchor Value\nSecond occurrence: *anchor'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'First occurrence: &anchor Value\nSecond occurrence: *anchor'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JS2J'
yaml_content = 'First occurrence: &anchor Value\nSecond occurrence: *anchor'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'First occurrence: &anchor Value\nSecond occurrence: *anchor'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JS2J'
yaml_content = 'First occurrence: &anchor Value\nSecond occurrence: *anchor'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test JS2J: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[LHL4----\n!invalid{}tag scalar] ________________

source = '---\n!invalid{}tag scalar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n!invalid{}tag scalar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'LHL4', yaml_content = '---\n!invalid{}tag scalar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n!invalid{}tag scalar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'LHL4', yaml_content = '---\n!invalid{}tag scalar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test LHL4: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[36F6----\nplain: a\n b\n\n c] _________________

source = '---\nplain: a\n b\n\n c'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nplain: a\n b\n\n c'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '36F6', yaml_content = '---\nplain: a\n b\n\n c'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nplain: a\n b\n\n c'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '36F6', yaml_content = '---\nplain: a\n b\n\n c'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 36F6: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
_________ test_yaml_suite[RTP8-%YAML 1.2\n---\nDocument\n... # Suffix] _________

source = '%YAML 1.2\n---\nDocument\n... # Suffix'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML 1.2\n---\nDocument\n... # Suffix'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RTP8', yaml_content = '%YAML 1.2\n---\nDocument\n... # Suffix'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML 1.2\n---\nDocument\n... # Suffix'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RTP8', yaml_content = '%YAML 1.2\n---\nDocument\n... # Suffix'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test RTP8: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________________ test_yaml_suite[QT73-# comment\n...] _____________________

source = '# comment\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# comment\n...'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'QT73', yaml_content = '# comment\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# comment\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'QT73', yaml_content = '# comment\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test QT73: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[FRK4-{\n  ? foo :,\n  : bar,\n}] _______________

source = '{\n  ? foo :,\n  : bar,\n}'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '{\n  ? foo :,\n  : bar,\n}'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FRK4', yaml_content = '{\n  ? foo :,\n  : bar,\n}'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '{\n  ? foo :,\n  : bar,\n}'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FRK4', yaml_content = '{\n  ? foo :,\n  : bar,\n}'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test FRK4: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[2LFX-%FOO  bar baz # Should be ignored\n              # with a warning.\n---\n"foo"] _

source = '%FOO  bar baz # Should be ignored\n              # with a warning.\n---\n"foo"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%FOO  bar baz # Should be ignored\n              # with a warning.\n---\n"foo"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '2LFX'
yaml_content = '%FOO  bar baz # Should be ignored\n              # with a warning.\n---\n"foo"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%FOO  bar baz # Should be ignored\n              # with a warning.\n---\n"foo"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '2LFX'
yaml_content = '%FOO  bar baz # Should be ignored\n              # with a warning.\n---\n"foo"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 2LFX: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[PW8X-- &a\n- a\n-\n  &a : a\n  b: &b\n-\n  &c : &a\n-\n  ? &d\n-\n  ? &e\n  : &a] _

source = '- &a\n- a\n-\n  &a : a\n  b: &b\n-\n  &c : &a\n-\n  ? &d\n-\n  ? &e\n  : &a'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- &a\n- a\n-\n  &a : a\n  b: &b\n-\n  &c : &a\n-\n  ? &d\n-\n  ? &e\n  : &a'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'PW8X'
yaml_content = '- &a\n- a\n-\n  &a : a\n  b: &b\n-\n  &c : &a\n-\n  ? &d\n-\n  ? &e\n  : &a'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- &a\n- a\n-\n  &a : a\n  b: &b\n-\n  &c : &a\n-\n  ? &d\n-\n  ? &e\n  : &a'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'PW8X'
yaml_content = '- &a\n- a\n-\n  &a : a\n  b: &b\n-\n  &c : &a\n-\n  ? &d\n-\n  ? &e\n  : &a'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test PW8X: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[Q4CL-key1: "quoted1"\nkey2: "quoted2" trailing content\nkey3: "quoted3"] _

source = 'key1: "quoted1"\nkey2: "quoted2" trailing content\nkey3: "quoted3"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key1: "quoted1"\nkey2: "quoted2" trailing content\nkey3: "quoted3"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Q4CL'
yaml_content = 'key1: "quoted1"\nkey2: "quoted2" trailing content\nkey3: "quoted3"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key1: "quoted1"\nkey2: "quoted2" trailing content\nkey3: "quoted3"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Q4CL'
yaml_content = 'key1: "quoted1"\nkey2: "quoted2" trailing content\nkey3: "quoted3"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test Q4CL: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[S4JQ-# Assuming conventional resolution:\n- "12"\n- 12\n- ! 12] _

source = '# Assuming conventional resolution:\n- "12"\n- 12\n- ! 12'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Assuming conventional resolution:\n- "12"\n- 12\n- ! 12'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S4JQ'
yaml_content = '# Assuming conventional resolution:\n- "12"\n- 12\n- ! 12'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Assuming conventional resolution:\n- "12"\n- 12\n- ! 12'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S4JQ'
yaml_content = '# Assuming conventional resolution:\n- "12"\n- 12\n- ! 12'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test S4JQ: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[HU3P-key:\n  word1 word2\n  no: key] _____________

source = 'key:\n  word1 word2\n  no: key'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key:\n  word1 word2\n  no: key'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'HU3P', yaml_content = 'key:\n  word1 word2\n  no: key'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key:\n  word1 word2\n  no: key'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'HU3P', yaml_content = 'key:\n  word1 word2\n  no: key'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test HU3P: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_____ test_yaml_suite[Z67P-literal: |2\n  value\nfolded: !foo >1\n value] ______

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'literal: |2\n  value\nfolded: !foo >1\n value'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557246.557796725, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = 'literal: |2\n  value\nfolded: !foo >1\n value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'literal: |2\n  value\nfolded: !foo >1\n value'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = 'Z67P', yaml_content = 'literal: |2\n  value\nfolded: !foo >1\n value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'literal: |2\n  value\nfolded: !foo >1\n value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Z67P', yaml_content = 'literal: |2\n  value\nfolded: !foo >1\n value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test Z67P: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[9U5K----\n# Products purchased\n- item    : Super Hoop\n  quantity: 1\n- item    : Basketball\n  quantity: 4\n- item    : Big Shoes\n  quantity: 1] _

source = '---\n# Products purchased\n- item    : Super Hoop\n  quantity: 1\n- item    : Basketball\n  quantity: 4\n- item    : Big Shoes\n  quantity: 1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n# Products purchased\n- item    : Super Hoop\n  quantity: 1\n- item    : Basketball\n  quantity: 4\n- item    : Big Shoes\n  quantity: 1'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9U5K'
yaml_content = '---\n# Products purchased\n- item    : Super Hoop\n  quantity: 1\n- item    : Basketball\n  quantity: 4\n- item    : Big Shoes\n  quantity: 1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n# Products purchased\n- item    : Super Hoop\n  quantity: 1\n- item    : Basketball\n  quantity: 4\n- item    : Big Shoes\n  quantity: 1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9U5K'
yaml_content = '---\n# Products purchased\n- item    : Super Hoop\n  quantity: 1\n- item    : Basketball\n  quantity: 4\n- item    : Big Shoes\n  quantity: 1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9U5K: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_________ test_yaml_suite[33X3----\n- !!int 1\n- !!int -2\n- !!int 33] _________

source = '---\n- !!int 1\n- !!int -2\n- !!int 33'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n- !!int 1\n- !!int -2\n- !!int 33'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '33X3', yaml_content = '---\n- !!int 1\n- !!int -2\n- !!int 33'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n- !!int 1\n- !!int -2\n- !!int 33'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '33X3', yaml_content = '---\n- !!int 1\n- !!int -2\n- !!int 33'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 33X3: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
__________________ test_yaml_suite[J7VC-one: 2\n\n\nthree: 4] __________________

source = 'one: 2\n\n\nthree: 4'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'one: 2\n\n\nthree: 4'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J7VC', yaml_content = 'one: 2\n\n\nthree: 4'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'one: 2\n\n\nthree: 4'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J7VC', yaml_content = 'one: 2\n\n\nthree: 4'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test J7VC: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[J9HZ----\nhr: # 1998 hr ranking\n  - Mark McGwire\n  - Sammy Sosa\nrbi:\n  # 1998 rbi ranking\n  - Sammy Sosa\n  - Ken Griffey] _

source = '---\nhr: # 1998 hr ranking\n  - Mark McGwire\n  - Sammy Sosa\nrbi:\n  # 1998 rbi ranking\n  - Sammy Sosa\n  - Ken Griffey'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nhr: # 1998 hr ranking\n  - Mark McGwire\n  - Sammy Sosa\nrbi:\n  # 1998 rbi ranking\n  - Sammy Sosa\n  - Ken Griffey'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J9HZ'
yaml_content = '---\nhr: # 1998 hr ranking\n  - Mark McGwire\n  - Sammy Sosa\nrbi:\n  # 1998 rbi ranking\n  - Sammy Sosa\n  - Ken Griffey'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nhr: # 1998 hr ranking\n  - Mark McGwire\n  - Sammy Sosa\nrbi:\n  # 1998 rbi ranking\n  - Sammy Sosa\n  - Ken Griffey'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J9HZ'
yaml_content = '---\nhr: # 1998 hr ranking\n  - Mark McGwire\n  - Sammy Sosa\nrbi:\n  # 1998 rbi ranking\n  - Sammy Sosa\n  - Ken Griffey'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test J9HZ: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[UGM3---- !<tag:clarkevans.com,2002:invoice>\ninvoice: 34843\ndate   : 2001-01-23\nbill-to: &id001\n    given  : Chris\n    family : Dumars\n    address:\n        lines: |\n            458 Walkman Dr.\n            Suite #292\n        city    : Royal Oak\n        state   : MI\n        postal  : 48046\nship-to: *id001\nproduct:\n    - sku         : BL394D\n      quantity    : 4\n      description : Basketball\n      price       : 450.00\n    - sku         : BL4438H\n      quantity    : 1\n      description : Super Hoop\n      price       : 2392.00\ntax  : 251.42\ntotal: 4443.52\ncomments:\n    Late afternoon is best.\n    Backup contact is Nancy\n    Billsmer @ 338-4338.] _

source = '--- !<tag:clarkevans.com,2002:invoice>\ninvoice: 34843\ndate   : 2001-01-23\nbill-to: &id001\n    given  : Chris\n   ... 251.42\ntotal: 4443.52\ncomments:\n    Late afternoon is best.\n    Backup contact is Nancy\n    Billsmer @ 338-4338.'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '--- !<tag:clarkevans.com,2002:invoice>\ninvoice: 34843\ndate   : 2001-01-23\nbill-to: &id001\n    given  : Chris\n   ... 251.42\ntotal: 4443.52\ncomments:\n    Late afternoon is best.\n    Backup contact is Nancy\n    Billsmer @ 338-4338.'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'UGM3'
yaml_content = '--- !<tag:clarkevans.com,2002:invoice>\ninvoice: 34843\ndate   : 2001-01-23\nbill-to: &id001\n    given  : Chris\n   ... 251.42\ntotal: 4443.52\ncomments:\n    Late afternoon is best.\n    Backup contact is Nancy\n    Billsmer @ 338-4338.'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '--- !<tag:clarkevans.com,2002:invoice>\ninvoice: 34843\ndate   : 2001-01-23\nbill-to: &id001\n    given  : Chris\n   ... 251.42\ntotal: 4443.52\ncomments:\n    Late afternoon is best.\n    Backup contact is Nancy\n    Billsmer @ 338-4338.'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'UGM3'
yaml_content = '--- !<tag:clarkevans.com,2002:invoice>\ninvoice: 34843\ndate   : 2001-01-23\nbill-to: &id001\n    given  : Chris\n   ... 251.42\ntotal: 4443.52\ncomments:\n    Late afternoon is best.\n    Backup contact is Nancy\n    Billsmer @ 338-4338.'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test UGM3: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[HMK4-name: Mark McGwire\naccomplishment: >\n  Mark set a major league\n  home run record in 1998.\nstats: |\n  65 Home Runs\n  0.278 Batting Average] _

source = 'name: Mark McGwire\naccomplishment: >\n  Mark set a major league\n  home run record in 1998.\nstats: |\n  65 Home Runs\n  0.278 Batting Average'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'name: Mark McGwire\naccomplishment: >\n  Mark set a major league\n  home run record in 1998.\nstats: |\n  65 Home Runs\n  0.278 Batting Average'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'HMK4'
yaml_content = 'name: Mark McGwire\naccomplishment: >\n  Mark set a major league\n  home run record in 1998.\nstats: |\n  65 Home Runs\n  0.278 Batting Average'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'name: Mark McGwire\naccomplishment: >\n  Mark set a major league\n  home run record in 1998.\nstats: |\n  65 Home Runs\n  0.278 Batting Average'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'HMK4'
yaml_content = 'name: Mark McGwire\naccomplishment: >\n  Mark set a major league\n  home run record in 1998.\nstats: |\n  65 Home Runs\n  0.278 Batting Average'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test HMK4: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[6H3V-'foo: bar\\': baz'] ___________________

source = "'foo: bar\\': baz'"

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = "'foo: bar\\': baz'"

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6H3V', yaml_content = "'foo: bar\\': baz'"

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = "'foo: bar\\': baz'"

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6H3V', yaml_content = "'foo: bar\\': baz'"

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6H3V: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[5GBF-Folding:\n  "Empty line\n   \xbb\n  as a line feed"\nChomping: |\n  Clipped empty lines\n\u2423\n\u21b5] _

source = 'Folding:\n  "Empty line\n   Â»\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'Folding:\n  "Empty line\n   Â»\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '5GBF'
yaml_content = 'Folding:\n  "Empty line\n   Â»\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'Folding:\n  "Empty line\n   Â»\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '5GBF'
yaml_content = 'Folding:\n  "Empty line\n   Â»\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 5GBF: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
_________________ test_yaml_suite[D49Q-'a\\nb': 1\n'c\n d': 1] _________________

source = "'a\\nb': 1\n'c\n d': 1"

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = "'a\\nb': 1\n'c\n d': 1"

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'D49Q', yaml_content = "'a\\nb': 1\n'c\n d': 1"

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = "'a\\nb': 1\n'c\n d': 1"

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'D49Q', yaml_content = "'a\\nb': 1\n'c\n d': 1"

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test D49Q: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_________________________ test_yaml_suite[2G84---- |0] _________________________

source = '--- |0'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '--- |0'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '2G84', yaml_content = '--- |0'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '--- |0'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '2G84', yaml_content = '--- |0'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 2G84: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
______ test_yaml_suite[HMQ5-!!str &a1 "foo":\n  !!str bar\n&a2 baz : *a1] ______

source = '!!str &a1 "foo":\n  !!str bar\n&a2 baz : *a1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '!!str &a1 "foo":\n  !!str bar\n&a2 baz : *a1'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'HMQ5', yaml_content = '!!str &a1 "foo":\n  !!str bar\n&a2 baz : *a1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '!!str &a1 "foo":\n  !!str bar\n&a2 baz : *a1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'HMQ5', yaml_content = '!!str &a1 "foo":\n  !!str bar\n&a2 baz : *a1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test HMQ5: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[G7JE-a\\nb: 1\nc\n d: 1] ___________________

source = 'a\\nb: 1\nc\n d: 1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'a\\nb: 1\nc\n d: 1'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'G7JE', yaml_content = 'a\\nb: 1\nc\n d: 1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'a\\nb: 1\nc\n d: 1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'G7JE', yaml_content = 'a\\nb: 1\nc\n d: 1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test G7JE: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[MZX3-- plain\n- "double quoted"\n- 'single quoted'\n- >\n  block\n- plain again] _

source = '- plain\n- "double quoted"\n- \'single quoted\'\n- >\n  block\n- plain again'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- plain\n- "double quoted"\n- \'single quoted\'\n- >\n  block\n- plain again'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'MZX3'
yaml_content = '- plain\n- "double quoted"\n- \'single quoted\'\n- >\n  block\n- plain again'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- plain\n- "double quoted"\n- \'single quoted\'\n- >\n  block\n- plain again'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'MZX3'
yaml_content = '- plain\n- "double quoted"\n- \'single quoted\'\n- >\n  block\n- plain again'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test MZX3: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[Q8AD----\n"folded\u2423\nto a space,\n\u2423\nto a line feed, or \xbb\\\n \\ \xbbnon-content"] _

source = '---\n"foldedâ£\nto a space,\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n"foldedâ£\nto a space,\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Q8AD'
yaml_content = '---\n"foldedâ£\nto a space,\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n"foldedâ£\nto a space,\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Q8AD'
yaml_content = '---\n"foldedâ£\nto a space,\nâ£\nto a line feed, or Â»\\\n \\ Â»non-content"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test Q8AD: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________________ test_yaml_suite[G5U8----\n- [-, -]] ______________________

source = '---\n- [-, -]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n- [-, -]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'G5U8', yaml_content = '---\n- [-, -]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n- [-, -]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'G5U8', yaml_content = '---\n- [-, -]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test G5U8: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
______ test_yaml_suite[NB6Z-key:\n  value\n  with\n  \u2014\xbb\n  tabs] _______

source = 'key:\n  value\n  with\n  â€”Â»\n  tabs'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key:\n  value\n  with\n  â€”Â»\n  tabs'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NB6Z', yaml_content = 'key:\n  value\n  with\n  â€”Â»\n  tabs'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key:\n  value\n  with\n  â€”Â»\n  tabs'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NB6Z', yaml_content = 'key:\n  value\n  with\n  â€”Â»\n  tabs'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test NB6Z: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[6PBE----\n?\n- a\n- b\n:\n- c\n- d] ______________

source = '---\n?\n- a\n- b\n:\n- c\n- d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n?\n- a\n- b\n:\n- c\n- d'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6PBE', yaml_content = '---\n?\n- a\n- b\n:\n- c\n- d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n?\n- a\n- b\n:\n- c\n- d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6PBE', yaml_content = '---\n?\n- a\n- b\n:\n- c\n- d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6PBE: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
__________________ test_yaml_suite[ZXT5-[ "key"\n  :value ]] ___________________

source = '[ "key"\n  :value ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '[ "key"\n  :value ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZXT5', yaml_content = '[ "key"\n  :value ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '[ "key"\n  :value ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZXT5', yaml_content = '[ "key"\n  :value ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test ZXT5: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[K4SU-- foo\n- bar\n- 42] ___________________

source = '- foo\n- bar\n- 42'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- foo\n- bar\n- 42'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'K4SU', yaml_content = '- foo\n- bar\n- 42'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- foo\n- bar\n- 42'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'K4SU', yaml_content = '- foo\n- bar\n- 42'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test K4SU: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[7BMT----\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4: &node4\n  &k4 key4: four\ntop5: &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven] _

source = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4: &node4\n  &k4 key4: four\ntop5: &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4: &node4\n  &k4 key4: four\ntop5: &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '7BMT'
yaml_content = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4: &node4\n  &k4 key4: four\ntop5: &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4: &node4\n  &k4 key4: four\ntop5: &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '7BMT'
yaml_content = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4: &node4\n  &k4 key4: four\ntop5: &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 7BMT: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[G4RS-unicode: "Sosa did fine.\\u263A"\ncontrol: "\\b1998\\t1999\\t2000\\n"\nhex esc: "\\x0d\\x0a is \\r\\n"\n\nsingle: '"Howdy!" he cried.'\nquoted: ' # Not a ''comment''.'\ntie-fighter: '|\\-*-/|'] _

source = 'unicode: "Sosa did fine.\\u263A"\ncontrol: "\\b1998\\t1999\\t2000\\n"\nhex esc: "\\x0d\\x0a is \\r\\n"\n\nsingle: \'"Howdy!" he cried.\'\nquoted: \' # Not a \'\'comment\'\'.\'\ntie-fighter: \'|\\-*-/|\''

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'unicode: "Sosa did fine.\\u263A"\ncontrol: "\\b1998\\t1999\\t2000\\n"\nhex esc: "\\x0d\\x0a is \\r\\n"\n\nsingle: \'"Howdy!" he cried.\'\nquoted: \' # Not a \'\'comment\'\'.\'\ntie-fighter: \'|\\-*-/|\''

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 6: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'G4RS'
yaml_content = 'unicode: "Sosa did fine.\\u263A"\ncontrol: "\\b1998\\t1999\\t2000\\n"\nhex esc: "\\x0d\\x0a is \\r\\n"\n\nsingle: \'"Howdy!" he cried.\'\nquoted: \' # Not a \'\'comment\'\'.\'\ntie-fighter: \'|\\-*-/|\''

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'unicode: "Sosa did fine.\\u263A"\ncontrol: "\\b1998\\t1999\\t2000\\n"\nhex esc: "\\x0d\\x0a is \\r\\n"\n\nsingle: \'"Howdy!" he cried.\'\nquoted: \' # Not a \'\'comment\'\'.\'\ntie-fighter: \'|\\-*-/|\''

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 6: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'G4RS'
yaml_content = 'unicode: "Sosa did fine.\\u263A"\ncontrol: "\\b1998\\t1999\\t2000\\n"\nhex esc: "\\x0d\\x0a is \\r\\n"\n\nsingle: \'"Howdy!" he cried.\'\nquoted: \' # Not a \'\'comment\'\'.\'\ntie-fighter: \'|\\-*-/|\''

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test G4RS: Parser error: Parser error: Parse error at line 6: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[5BVJ-literal: |\n  some\n  text\nfolded: >\n  some\n  text] __

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'literal: |\n  some\n  text\nfolded: >\n  some\n  text'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557251.854490822, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = 'literal: |\n  some\n  text\nfolded: >\n  some\n  text'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'literal: |\n  some\n  text\nfolded: >\n  some\n  text'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = '5BVJ'
yaml_content = 'literal: |\n  some\n  text\nfolded: >\n  some\n  text'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'literal: |\n  some\n  text\nfolded: >\n  some\n  text'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '5BVJ'
yaml_content = 'literal: |\n  some\n  text\nfolded: >\n  some\n  text'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 5BVJ: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[8UDB-[\n"double\n quoted", 'single\n           quoted',\nplain\n text, [ nested ],\nsingle: pair,\n]] _

source = '[\n"double\n quoted", \'single\n           quoted\',\nplain\n text, [ nested ],\nsingle: pair,\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '[\n"double\n quoted", \'single\n           quoted\',\nplain\n text, [ nested ],\nsingle: pair,\n]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 7: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '8UDB'
yaml_content = '[\n"double\n quoted", \'single\n           quoted\',\nplain\n text, [ nested ],\nsingle: pair,\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '[\n"double\n quoted", \'single\n           quoted\',\nplain\n text, [ nested ],\nsingle: pair,\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 7: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '8UDB'
yaml_content = '[\n"double\n quoted", \'single\n           quoted\',\nplain\n text, [ nested ],\nsingle: pair,\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 8UDB: Parser error: Parser error: Parse error at line 7: syntax error

tests/test_yaml_suite.py:88: Failed
__________________ test_yaml_suite[6M2F-? &a a\n: &b b\n: *a] __________________

source = '? &a a\n: &b b\n: *a'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '? &a a\n: &b b\n: *a'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6M2F', yaml_content = '? &a a\n: &b b\n: *a'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '? &a a\n: &b b\n: *a'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6M2F', yaml_content = '? &a a\n: &b b\n: *a'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6M2F: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
____________________ test_yaml_suite[EW3V-k1: v1\n k2: v2] _____________________

source = 'k1: v1\n k2: v2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'k1: v1\n k2: v2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'EW3V', yaml_content = 'k1: v1\n k2: v2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'k1: v1\n k2: v2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'EW3V', yaml_content = 'k1: v1\n k2: v2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test EW3V: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[LQZ7-"implicit block key" : [\n  "implicit flow key" : value,\n ]] _

source = '"implicit block key" : [\n  "implicit flow key" : value,\n ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '"implicit block key" : [\n  "implicit flow key" : value,\n ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'LQZ7'
yaml_content = '"implicit block key" : [\n  "implicit flow key" : value,\n ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '"implicit block key" : [\n  "implicit flow key" : value,\n ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'LQZ7'
yaml_content = '"implicit block key" : [\n  "implicit flow key" : value,\n ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test LQZ7: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
__________________________ test_yaml_suite[YJV2-[-]] ___________________________

source = '[-]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '[-]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'YJV2', yaml_content = '[-]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '[-]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'YJV2', yaml_content = '[-]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test YJV2: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[Z9M4-%TAG !e! tag:example.com,2000:app/\n---\n- !e!foo "bar"] _

source = '%TAG !e! tag:example.com,2000:app/\n---\n- !e!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%TAG !e! tag:example.com,2000:app/\n---\n- !e!foo "bar"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Z9M4'
yaml_content = '%TAG !e! tag:example.com,2000:app/\n---\n- !e!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%TAG !e! tag:example.com,2000:app/\n---\n- !e!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'Z9M4'
yaml_content = '%TAG !e! tag:example.com,2000:app/\n---\n- !e!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test Z9M4: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
____ test_yaml_suite[6JQW-# ASCII Art\n--- |\n  \\//||\\/||\n  // ||  ||__] ____

source = '# ASCII Art\n--- |\n  \\//||\\/||\n  // ||  ||__'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# ASCII Art\n--- |\n  \\//||\\/||\n  // ||  ||__'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6JQW'
yaml_content = '# ASCII Art\n--- |\n  \\//||\\/||\n  // ||  ||__'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# ASCII Art\n--- |\n  \\//||\\/||\n  // ||  ||__'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6JQW'
yaml_content = '# ASCII Art\n--- |\n  \\//||\\/||\n  // ||  ||__'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6JQW: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[9HCY-!foo "bar"\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"] _

source = '!foo "bar"\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '!foo "bar"\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9HCY'
yaml_content = '!foo "bar"\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '!foo "bar"\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9HCY'
yaml_content = '!foo "bar"\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9HCY: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[JHB9-# Ranking of 1998 home runs\n---\n- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n\n# Team ranking\n---\n- Chicago Cubs\n- St Louis Cardinals] _

source = '# Ranking of 1998 home runs\n---\n- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n\n# Team ranking\n---\n- Chicago Cubs\n- St Louis Cardinals'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Ranking of 1998 home runs\n---\n- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n\n# Team ranking\n---\n- Chicago Cubs\n- St Louis Cardinals'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JHB9'
yaml_content = '# Ranking of 1998 home runs\n---\n- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n\n# Team ranking\n---\n- Chicago Cubs\n- St Louis Cardinals'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Ranking of 1998 home runs\n---\n- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n\n# Team ranking\n---\n- Chicago Cubs\n- St Louis Cardinals'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JHB9'
yaml_content = '# Ranking of 1998 home runs\n---\n- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n\n# Team ranking\n---\n- Chicago Cubs\n- St Louis Cardinals'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test JHB9: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
________ test_yaml_suite[4FJ6----\n[\n  [ a, [ [[b,c]]: d, e]]: 23\n]] _________

source = '---\n[\n  [ a, [ [[b,c]]: d, e]]: 23\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n[\n  [ a, [ [[b,c]]: d, e]]: 23\n]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '4FJ6', yaml_content = '---\n[\n  [ a, [ [[b,c]]: d, e]]: 23\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n[\n  [ a, [ [[b,c]]: d, e]]: 23\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '4FJ6', yaml_content = '---\n[\n  [ a, [ [[b,c]]: d, e]]: 23\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 4FJ6: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_________________ test_yaml_suite[7LBH-"a\\nb": 1\n"c\n d": 1] _________________

source = '"a\\nb": 1\n"c\n d": 1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '"a\\nb": 1\n"c\n d": 1'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '7LBH', yaml_content = '"a\\nb": 1\n"c\n d": 1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '"a\\nb": 1\n"c\n d": 1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '7LBH', yaml_content = '"a\\nb": 1\n"c\n d": 1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 7LBH: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[2CMS-this\n is\n  invalid: x] _________________

source = 'this\n is\n  invalid: x'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'this\n is\n  invalid: x'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '2CMS', yaml_content = 'this\n is\n  invalid: x'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'this\n is\n  invalid: x'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '2CMS', yaml_content = 'this\n is\n  invalid: x'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 2CMS: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[M7A3-Bare\ndocument\n...\n# No document\n...\n|\n%!PS-Adobe-2.0 # Not the first line] _

source = 'Bare\ndocument\n...\n# No document\n...\n|\n%!PS-Adobe-2.0 # Not the first line'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'Bare\ndocument\n...\n# No document\n...\n|\n%!PS-Adobe-2.0 # Not the first line'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'M7A3'
yaml_content = 'Bare\ndocument\n...\n# No document\n...\n|\n%!PS-Adobe-2.0 # Not the first line'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'Bare\ndocument\n...\n# No document\n...\n|\n%!PS-Adobe-2.0 # Not the first line'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'M7A3'
yaml_content = 'Bare\ndocument\n...\n# No document\n...\n|\n%!PS-Adobe-2.0 # Not the first line'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test M7A3: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[W42U-- # Empty\n- |\n block node\n- - one # Compact\n  - two # sequence\n- one: two # Compact mapping] _

source = '- # Empty\n- |\n block node\n- - one # Compact\n  - two # sequence\n- one: two # Compact mapping'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- # Empty\n- |\n block node\n- - one # Compact\n  - two # sequence\n- one: two # Compact mapping'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'W42U'
yaml_content = '- # Empty\n- |\n block node\n- - one # Compact\n  - two # sequence\n- one: two # Compact mapping'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- # Empty\n- |\n block node\n- - one # Compact\n  - two # sequence\n- one: two # Compact mapping'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'W42U'
yaml_content = '- # Empty\n- |\n block node\n- - one # Compact\n  - two # sequence\n- one: two # Compact mapping'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test W42U: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
__________________ test_yaml_suite[236B-foo:\n  bar\ninvalid] __________________

source = 'foo:\n  bar\ninvalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo:\n  bar\ninvalid'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '236B', yaml_content = 'foo:\n  bar\ninvalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'foo:\n  bar\ninvalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '236B', yaml_content = 'foo:\n  bar\ninvalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 236B: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[F6MC----\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular] _

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557257.127016989, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = '---\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = 'F6MC'
yaml_content = '---\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'F6MC'
yaml_content = '---\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test F6MC: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[JR7V-- a?string\n- another ? string\n- key: value?\n- [a?string]\n- [another ? string]\n- {key: value? }\n- {key: value?}\n- {key?: value }] _

source = '- a?string\n- another ? string\n- key: value?\n- [a?string]\n- [another ? string]\n- {key: value? }\n- {key: value?}\n- {key?: value }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- a?string\n- another ? string\n- key: value?\n- [a?string]\n- [another ? string]\n- {key: value? }\n- {key: value?}\n- {key?: value }'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JR7V'
yaml_content = '- a?string\n- another ? string\n- key: value?\n- [a?string]\n- [another ? string]\n- {key: value? }\n- {key: value?}\n- {key?: value }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- a?string\n- another ? string\n- key: value?\n- [a?string]\n- [another ? string]\n- {key: value? }\n- {key: value?}\n- {key?: value }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JR7V'
yaml_content = '- a?string\n- another ? string\n- key: value?\n- [a?string]\n- [another ? string]\n- {key: value? }\n- {key: value?}\n- {key?: value }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test JR7V: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
______ test_yaml_suite[FQ7F-- Mark McGwire\n- Sammy Sosa\n- Ken Griffey] _______

source = '- Mark McGwire\n- Sammy Sosa\n- Ken Griffey'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- Mark McGwire\n- Sammy Sosa\n- Ken Griffey'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FQ7F', yaml_content = '- Mark McGwire\n- Sammy Sosa\n- Ken Griffey'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- Mark McGwire\n- Sammy Sosa\n- Ken Griffey'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FQ7F', yaml_content = '- Mark McGwire\n- Sammy Sosa\n- Ken Griffey'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test FQ7F: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[9YRD-a\nb\u2423\u2423\n  c\nd\n\ne] ______________

source = 'a\nbâ£â£\n  c\nd\n\ne'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'a\nbâ£â£\n  c\nd\n\ne'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9YRD', yaml_content = 'a\nbâ£â£\n  c\nd\n\ne'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'a\nbâ£â£\n  c\nd\n\ne'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9YRD', yaml_content = 'a\nbâ£â£\n  c\nd\n\ne'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9YRD: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[H7TQ-%YAML 1.2 foo\n---] ___________________

source = '%YAML 1.2 foo\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML 1.2 foo\n---'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'H7TQ', yaml_content = '%YAML 1.2 foo\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML 1.2 foo\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'H7TQ', yaml_content = '%YAML 1.2 foo\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test H7TQ: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[UV7Q-x:\n - x\n  \u2014\u2014\xbbx] ______________

source = 'x:\n - x\n  â€”â€”Â»x'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'x:\n - x\n  â€”â€”Â»x'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'UV7Q', yaml_content = 'x:\n - x\n  â€”â€”Â»x'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'x:\n - x\n  â€”â€”Â»x'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'UV7Q', yaml_content = 'x:\n - x\n  â€”â€”Â»x'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test UV7Q: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
____ test_yaml_suite[V9D5-- sun: yellow\n- ? earth: blue\n  : moon: white] _____

source = '- sun: yellow\n- ? earth: blue\n  : moon: white'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- sun: yellow\n- ? earth: blue\n  : moon: white'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'V9D5'
yaml_content = '- sun: yellow\n- ? earth: blue\n  : moon: white'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- sun: yellow\n- ? earth: blue\n  : moon: white'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'V9D5'
yaml_content = '- sun: yellow\n- ? earth: blue\n  : moon: white'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test V9D5: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[NHX8-:\n\u21b5\n\u21b5] ____________________

source = ':\nâ†µ\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = ':\nâ†µ\nâ†µ'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NHX8', yaml_content = ':\nâ†µ\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = ':\nâ†µ\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NHX8', yaml_content = ':\nâ†µ\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test NHX8: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[RZT7----\nTime: 2001-11-23 15:01:42 -5\nUser: ed\nWarning:\n  This is an error message\n  for the log file\n---\nTime: 2001-11-23 15:02:31 -5\nUser: ed\nWarning:\n  A slightly different error\n  message.\n---\nDate: 2001-11-23 15:03:17 -5\nUser: ed\nFatal:\n  Unknown variable "bar"\nStack:\n  - file: TopClass.py\n    line: 23\n    code: |\n      x = MoreObject("345\\n")\n  - file: MoreClass.py\n    line: 58\n    code: |-\n      foo = bar] _

source = '---\nTime: 2001-11-23 15:01:42 -5\nUser: ed\nWarning:\n  This is an error message\n  for the log file\n---\nTime: 200...: 23\n    code: |\n      x = MoreObject("345\\n")\n  - file: MoreClass.py\n    line: 58\n    code: |-\n      foo = bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nTime: 2001-11-23 15:01:42 -5\nUser: ed\nWarning:\n  This is an error message\n  for the log file\n---\nTime: 200...: 23\n    code: |\n      x = MoreObject("345\\n")\n  - file: MoreClass.py\n    line: 58\n    code: |-\n      foo = bar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RZT7'
yaml_content = '---\nTime: 2001-11-23 15:01:42 -5\nUser: ed\nWarning:\n  This is an error message\n  for the log file\n---\nTime: 200...: 23\n    code: |\n      x = MoreObject("345\\n")\n  - file: MoreClass.py\n    line: 58\n    code: |-\n      foo = bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nTime: 2001-11-23 15:01:42 -5\nUser: ed\nWarning:\n  This is an error message\n  for the log file\n---\nTime: 200...: 23\n    code: |\n      x = MoreObject("345\\n")\n  - file: MoreClass.py\n    line: 58\n    code: |-\n      foo = bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RZT7'
yaml_content = '---\nTime: 2001-11-23 15:01:42 -5\nUser: ed\nWarning:\n  This is an error message\n  for the log file\n---\nTime: 200...: 23\n    code: |\n      x = MoreObject("345\\n")\n  - file: MoreClass.py\n    line: 58\n    code: |-\n      foo = bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test RZT7: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[RHX7----\nkey: value\n%YAML 1.2\n---] _____________

source = '---\nkey: value\n%YAML 1.2\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nkey: value\n%YAML 1.2\n---'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RHX7', yaml_content = '---\nkey: value\n%YAML 1.2\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nkey: value\n%YAML 1.2\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RHX7', yaml_content = '---\nkey: value\n%YAML 1.2\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test RHX7: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[9DXL-Mapping: Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20] _

source = 'Mapping: Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'Mapping: Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9DXL'
yaml_content = 'Mapping: Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'Mapping: Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9DXL'
yaml_content = 'Mapping: Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9DXL: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________ test_yaml_suite[DK3J---- >\nline1\n# no comment\nline3] ____________

source = '--- >\nline1\n# no comment\nline3'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '--- >\nline1\n# no comment\nline3'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DK3J', yaml_content = '--- >\nline1\n# no comment\nline3'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '--- >\nline1\n# no comment\nline3'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DK3J', yaml_content = '--- >\nline1\n# no comment\nline3'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test DK3J: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_________________ test_yaml_suite[F8F9-# Strip\n # Comments:] __________________

source = '# Strip\n # Comments:'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Strip\n # Comments:'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'F8F9', yaml_content = '# Strip\n # Comments:'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Strip\n # Comments:'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'F8F9', yaml_content = '# Strip\n # Comments:'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test F8F9: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
____________________ test_yaml_suite[82AN----word1\nword2] _____________________

source = '---word1\nword2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---word1\nword2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '82AN', yaml_content = '---word1\nword2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---word1\nword2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '82AN', yaml_content = '---word1\nword2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 82AN: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[5WE3-? explicit key # Empty value\n? |\n  block key\n: - one # Explicit compact\n  - two # block value] _

source = '? explicit key # Empty value\n? |\n  block key\n: - one # Explicit compact\n  - two # block value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '? explicit key # Empty value\n? |\n  block key\n: - one # Explicit compact\n  - two # block value'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '5WE3'
yaml_content = '? explicit key # Empty value\n? |\n  block key\n: - one # Explicit compact\n  - two # block value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '? explicit key # Empty value\n? |\n  block key\n: - one # Explicit compact\n  - two # block value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '5WE3'
yaml_content = '? explicit key # Empty value\n? |\n  block key\n: - one # Explicit compact\n  - two # block value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 5WE3: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________________ test_yaml_suite[B63P-%YAML 1.2\n...] _____________________

source = '%YAML 1.2\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML 1.2\n...'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'B63P', yaml_content = '%YAML 1.2\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML 1.2\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'B63P', yaml_content = '%YAML 1.2\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test B63P: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[KK5P-complex1:\n  ? - a\ncomplex2:\n  ? - a\n  : b\ncomplex3:\n  ? - a\n  : >\n    b\ncomplex4:\n  ? >\n    a\n  :\ncomplex5:\n  ? - a\n  : - b] _

source = 'complex1:\n  ? - a\ncomplex2:\n  ? - a\n  : b\ncomplex3:\n  ? - a\n  : >\n    b\ncomplex4:\n  ? >\n    a\n  :\ncomplex5:\n  ? - a\n  : - b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'complex1:\n  ? - a\ncomplex2:\n  ? - a\n  : b\ncomplex3:\n  ? - a\n  : >\n    b\ncomplex4:\n  ? >\n    a\n  :\ncomplex5:\n  ? - a\n  : - b'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'KK5P'
yaml_content = 'complex1:\n  ? - a\ncomplex2:\n  ? - a\n  : b\ncomplex3:\n  ? - a\n  : >\n    b\ncomplex4:\n  ? >\n    a\n  :\ncomplex5:\n  ? - a\n  : - b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'complex1:\n  ? - a\ncomplex2:\n  ? - a\n  : b\ncomplex3:\n  ? - a\n  : >\n    b\ncomplex4:\n  ? >\n    a\n  :\ncomplex5:\n  ? - a\n  : - b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'KK5P'
yaml_content = 'complex1:\n  ? - a\ncomplex2:\n  ? - a\n  : b\ncomplex3:\n  ? - a\n  : >\n    b\ncomplex4:\n  ? >\n    a\n  :\ncomplex5:\n  ? - a\n  : - b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test KK5P: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[6VJK->\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!] _

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '>\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557262.37251843, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = '>\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '>\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = '6VJK'
yaml_content = '>\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '>\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6VJK'
yaml_content = '>\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6VJK: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
_____ test_yaml_suite[F2C7-- &a !!str a\n- !!int 2\n- !!int &c 4\n- &d d] ______

source = '- &a !!str a\n- !!int 2\n- !!int &c 4\n- &d d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- &a !!str a\n- !!int 2\n- !!int &c 4\n- &d d'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'F2C7', yaml_content = '- &a !!str a\n- !!int 2\n- !!int &c 4\n- &d d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- &a !!str a\n- !!int 2\n- !!int &c 4\n- &d d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'F2C7', yaml_content = '- &a !!str a\n- !!int 2\n- !!int &c 4\n- &d d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test F2C7: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[FH7J-- !!str\n-\n  !!null : a\n  b: !!str\n- !!str : !!null] _

source = '- !!str\n-\n  !!null : a\n  b: !!str\n- !!str : !!null'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- !!str\n-\n  !!null : a\n  b: !!str\n- !!str : !!null'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FH7J'
yaml_content = '- !!str\n-\n  !!null : a\n  b: !!str\n- !!str : !!null'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- !!str\n-\n  !!null : a\n  b: !!str\n- !!str : !!null'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FH7J'
yaml_content = '- !!str\n-\n  !!null : a\n  b: !!str\n- !!str : !!null'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test FH7J: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[PBJ2-american:\n  - Boston Red Sox\n  - Detroit Tigers\n  - New York Yankees\nnational:\n  - New York Mets\n  - Chicago Cubs\n  - Atlanta Braves] _

source = 'american:\n  - Boston Red Sox\n  - Detroit Tigers\n  - New York Yankees\nnational:\n  - New York Mets\n  - Chicago Cubs\n  - Atlanta Braves'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'american:\n  - Boston Red Sox\n  - Detroit Tigers\n  - New York Yankees\nnational:\n  - New York Mets\n  - Chicago Cubs\n  - Atlanta Braves'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'PBJ2'
yaml_content = 'american:\n  - Boston Red Sox\n  - Detroit Tigers\n  - New York Yankees\nnational:\n  - New York Mets\n  - Chicago Cubs\n  - Atlanta Braves'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'american:\n  - Boston Red Sox\n  - Detroit Tigers\n  - New York Yankees\nnational:\n  - New York Mets\n  - Chicago Cubs\n  - Atlanta Braves'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'PBJ2'
yaml_content = 'american:\n  - Boston Red Sox\n  - Detroit Tigers\n  - New York Yankees\nnational:\n  - New York Mets\n  - Chicago Cubs\n  - Atlanta Braves'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test PBJ2: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[CQ3W----\nkey: "missing closing quote] ____________

source = '---\nkey: "missing closing quote'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nkey: "missing closing quote'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CQ3W', yaml_content = '---\nkey: "missing closing quote'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nkey: "missing closing quote'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CQ3W', yaml_content = '---\nkey: "missing closing quote'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test CQ3W: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[W4TN-%YAML 1.2\n--- |\n%!PS-Adobe-2.0\n...\n%YAML 1.2\n---\n# Empty\n...] _

source = '%YAML 1.2\n--- |\n%!PS-Adobe-2.0\n...\n%YAML 1.2\n---\n# Empty\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML 1.2\n--- |\n%!PS-Adobe-2.0\n...\n%YAML 1.2\n---\n# Empty\n...'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'W4TN'
yaml_content = '%YAML 1.2\n--- |\n%!PS-Adobe-2.0\n...\n%YAML 1.2\n---\n# Empty\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML 1.2\n--- |\n%!PS-Adobe-2.0\n...\n%YAML 1.2\n---\n# Empty\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'W4TN'
yaml_content = '%YAML 1.2\n--- |\n%!PS-Adobe-2.0\n...\n%YAML 1.2\n---\n# Empty\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test W4TN: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_________________ test_yaml_suite[XLQ9----\nscalar\n%YAML 1.2] _________________

source = '---\nscalar\n%YAML 1.2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nscalar\n%YAML 1.2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'XLQ9', yaml_content = '---\nscalar\n%YAML 1.2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nscalar\n%YAML 1.2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'XLQ9', yaml_content = '---\nscalar\n%YAML 1.2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test XLQ9: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
______ test_yaml_suite[W5VH-a: &:@*!$"<foo>: scalar a\nb: *:@*!$"<foo>:] _______

source = 'a: &:@*!$"<foo>: scalar a\nb: *:@*!$"<foo>:'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'a: &:@*!$"<foo>: scalar a\nb: *:@*!$"<foo>:'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'W5VH', yaml_content = 'a: &:@*!$"<foo>: scalar a\nb: *:@*!$"<foo>:'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'a: &:@*!$"<foo>: scalar a\nb: *:@*!$"<foo>:'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'W5VH', yaml_content = 'a: &:@*!$"<foo>: scalar a\nb: *:@*!$"<foo>:'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test W5VH: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
__ test_yaml_suite[U44R-map:\n  key1: "quoted1"\n   key2: "bad indentation"] ___

source = 'map:\n  key1: "quoted1"\n   key2: "bad indentation"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'map:\n  key1: "quoted1"\n   key2: "bad indentation"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'U44R'
yaml_content = 'map:\n  key1: "quoted1"\n   key2: "bad indentation"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'map:\n  key1: "quoted1"\n   key2: "bad indentation"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'U44R'
yaml_content = 'map:\n  key1: "quoted1"\n   key2: "bad indentation"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test U44R: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
______________ test_yaml_suite[BD7L-- item1\n- item2\ninvalid: x] ______________

source = '- item1\n- item2\ninvalid: x'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- item1\n- item2\ninvalid: x'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'BD7L', yaml_content = '- item1\n- item2\ninvalid: x'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- item1\n- item2\ninvalid: x'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'BD7L', yaml_content = '- item1\n- item2\ninvalid: x'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test BD7L: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[4CQQ-plain:\n  This unquoted scalar\n  spans many lines.\n\nquoted: "So does this\n  quoted scalar.\\n"] _

source = 'plain:\n  This unquoted scalar\n  spans many lines.\n\nquoted: "So does this\n  quoted scalar.\\n"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'plain:\n  This unquoted scalar\n  spans many lines.\n\nquoted: "So does this\n  quoted scalar.\\n"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '4CQQ'
yaml_content = 'plain:\n  This unquoted scalar\n  spans many lines.\n\nquoted: "So does this\n  quoted scalar.\\n"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'plain:\n  This unquoted scalar\n  spans many lines.\n\nquoted: "So does this\n  quoted scalar.\\n"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '4CQQ'
yaml_content = 'plain:\n  This unquoted scalar\n  spans many lines.\n\nquoted: "So does this\n  quoted scalar.\\n"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 4CQQ: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_________________ test_yaml_suite[ZVH3-- key: value\n - item1] _________________

source = '- key: value\n - item1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- key: value\n - item1'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZVH3', yaml_content = '- key: value\n - item1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- key: value\n - item1'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZVH3', yaml_content = '- key: value\n - item1'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test ZVH3: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[6JWB-foo: !!seq\n  - !!str a\n  - !!map\n    key: !!str value] _

source = 'foo: !!seq\n  - !!str a\n  - !!map\n    key: !!str value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo: !!seq\n  - !!str a\n  - !!map\n    key: !!str value'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6JWB'
yaml_content = 'foo: !!seq\n  - !!str a\n  - !!map\n    key: !!str value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'foo: !!seq\n  - !!str a\n  - !!map\n    key: !!str value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6JWB'
yaml_content = 'foo: !!seq\n  - !!str a\n  - !!map\n    key: !!str value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6JWB: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[9KAX----\n&a1\n!!str\nscalar1\n---\n!!str\n&a2\nscalar2\n---\n&a3\n!!str scalar3\n---\n&a4 !!map\n&a5 !!str key5: value4\n---\na6: 1\n&anchor6 b6: 2\n---\n!!map\n&a8 !!str key8: value7\n---\n!!map\n!!str &a10 key10: value9\n---\n!!str &a11\nvalue11] _

source = '---\n&a1\n!!str\nscalar1\n---\n!!str\n&a2\nscalar2\n---\n&a3\n!!str scalar3\n---\n&a4 !!map\n&a5 !!str key5: value4\n... 1\n&anchor6 b6: 2\n---\n!!map\n&a8 !!str key8: value7\n---\n!!map\n!!str &a10 key10: value9\n---\n!!str &a11\nvalue11'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n&a1\n!!str\nscalar1\n---\n!!str\n&a2\nscalar2\n---\n&a3\n!!str scalar3\n---\n&a4 !!map\n&a5 !!str key5: value4\n... 1\n&anchor6 b6: 2\n---\n!!map\n&a8 !!str key8: value7\n---\n!!map\n!!str &a10 key10: value9\n---\n!!str &a11\nvalue11'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9KAX'
yaml_content = '---\n&a1\n!!str\nscalar1\n---\n!!str\n&a2\nscalar2\n---\n&a3\n!!str scalar3\n---\n&a4 !!map\n&a5 !!str key5: value4\n... 1\n&anchor6 b6: 2\n---\n!!map\n&a8 !!str key8: value7\n---\n!!map\n!!str &a10 key10: value9\n---\n!!str &a11\nvalue11'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n&a1\n!!str\nscalar1\n---\n!!str\n&a2\nscalar2\n---\n&a3\n!!str scalar3\n---\n&a4 !!map\n&a5 !!str key5: value4\n... 1\n&anchor6 b6: 2\n---\n!!map\n&a8 !!str key8: value7\n---\n!!map\n!!str &a10 key10: value9\n---\n!!str &a11\nvalue11'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9KAX'
yaml_content = '---\n&a1\n!!str\nscalar1\n---\n!!str\n&a2\nscalar2\n---\n&a3\n!!str scalar3\n---\n&a4 !!map\n&a5 !!str key5: value4\n... 1\n&anchor6 b6: 2\n---\n!!map\n&a8 !!str key8: value7\n---\n!!map\n!!str &a10 key10: value9\n---\n!!str &a11\nvalue11'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9KAX: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
__________________ test_yaml_suite[E76Z-&a a: &b b\n*b : *a] ___________________

source = '&a a: &b b\n*b : *a'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '&a a: &b b\n*b : *a'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'E76Z', yaml_content = '&a a: &b b\n*b : *a'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '&a a: &b b\n*b : *a'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'E76Z', yaml_content = '&a a: &b b\n*b : *a'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test E76Z: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[M6YH-- |\n x\n-\n foo: bar\n-\n - 42] _____________

source = '- |\n x\n-\n foo: bar\n-\n - 42'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- |\n x\n-\n foo: bar\n-\n - 42'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'M6YH', yaml_content = '- |\n x\n-\n foo: bar\n-\n - 42'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- |\n x\n-\n foo: bar\n-\n - 42'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'M6YH', yaml_content = '- |\n x\n-\n foo: bar\n-\n - 42'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test M6YH: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[D83L-- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent] _

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557267.649306931, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = '- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = 'D83L'
yaml_content = '- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'D83L'
yaml_content = '- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test D83L: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[GT5M-- item1\n&node\n- item2] _________________

source = '- item1\n&node\n- item2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- item1\n&node\n- item2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'GT5M', yaml_content = '- item1\n&node\n- item2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- item1\n&node\n- item2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'GT5M', yaml_content = '- item1\n&node\n- item2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test GT5M: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[M5DY-? - Detroit Tigers\n  - Chicago cubs\n:\n  - 2001-07-23\n\n? [ New York Yankees,\n    Atlanta Braves ]\n: [ 2001-07-02, 2001-08-12,\n    2001-08-14 ]] _

source = '? - Detroit Tigers\n  - Chicago cubs\n:\n  - 2001-07-23\n\n? [ New York Yankees,\n    Atlanta Braves ]\n: [ 2001-07-02, 2001-08-12,\n    2001-08-14 ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '? - Detroit Tigers\n  - Chicago cubs\n:\n  - 2001-07-23\n\n? [ New York Yankees,\n    Atlanta Braves ]\n: [ 2001-07-02, 2001-08-12,\n    2001-08-14 ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'M5DY'
yaml_content = '? - Detroit Tigers\n  - Chicago cubs\n:\n  - 2001-07-23\n\n? [ New York Yankees,\n    Atlanta Braves ]\n: [ 2001-07-02, 2001-08-12,\n    2001-08-14 ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '? - Detroit Tigers\n  - Chicago cubs\n:\n  - 2001-07-23\n\n? [ New York Yankees,\n    Atlanta Braves ]\n: [ 2001-07-02, 2001-08-12,\n    2001-08-14 ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'M5DY'
yaml_content = '? - Detroit Tigers\n  - Chicago cubs\n:\n  - 2001-07-23\n\n? [ New York Yankees,\n    Atlanta Braves ]\n: [ 2001-07-02, 2001-08-12,\n    2001-08-14 ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test M5DY: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[CC74-%TAG !e! tag:example.com,2000:app/\n---\n!e!foo "bar"] __

source = '%TAG !e! tag:example.com,2000:app/\n---\n!e!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%TAG !e! tag:example.com,2000:app/\n---\n!e!foo "bar"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CC74'
yaml_content = '%TAG !e! tag:example.com,2000:app/\n---\n!e!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%TAG !e! tag:example.com,2000:app/\n---\n!e!foo "bar"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CC74'
yaml_content = '%TAG !e! tag:example.com,2000:app/\n---\n!e!foo "bar"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test CC74: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_______ test_yaml_suite[A2M4-? a\n: -\xbbb\n  -  -\u2014\xbbc\n     - d] _______

source = '? a\n: -Â»b\n  -  -â€”Â»c\n     - d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '? a\n: -Â»b\n  -  -â€”Â»c\n     - d'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'A2M4', yaml_content = '? a\n: -Â»b\n  -  -â€”Â»c\n     - d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '? a\n: -Â»b\n  -  -â€”Â»c\n     - d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'A2M4', yaml_content = '? a\n: -Â»b\n  -  -â€”Â»c\n     - d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test A2M4: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[J5UC-foo: blue\nbar: arrr\nbaz: jazz] _____________

source = 'foo: blue\nbar: arrr\nbaz: jazz'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo: blue\nbar: arrr\nbaz: jazz'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J5UC', yaml_content = 'foo: blue\nbar: arrr\nbaz: jazz'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'foo: blue\nbar: arrr\nbaz: jazz'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J5UC', yaml_content = 'foo: blue\nbar: arrr\nbaz: jazz'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test J5UC: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[CN3R-&flowseq [\n a: b,\n &c c: d,\n { &e e: f },\n &g { g: h }\n]] _

source = '&flowseq [\n a: b,\n &c c: d,\n { &e e: f },\n &g { g: h }\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '&flowseq [\n a: b,\n &c c: d,\n { &e e: f },\n &g { g: h }\n]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CN3R'
yaml_content = '&flowseq [\n a: b,\n &c c: d,\n { &e e: f },\n &g { g: h }\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '&flowseq [\n a: b,\n &c c: d,\n { &e e: f },\n &g { g: h }\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CN3R'
yaml_content = '&flowseq [\n a: b,\n &c c: d,\n { &e e: f },\n &g { g: h }\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test CN3R: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[7MNF-top1:\n  key1: val1\ntop2] ________________

source = 'top1:\n  key1: val1\ntop2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'top1:\n  key1: val1\ntop2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '7MNF', yaml_content = 'top1:\n  key1: val1\ntop2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'top1:\n  key1: val1\ntop2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '7MNF', yaml_content = 'top1:\n  key1: val1\ntop2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 7MNF: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[FBC9-safe: a!"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\n     !"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\nsafe question mark: ?foo\nsafe colon: :foo\nsafe dash: -foo] _

source = 'safe: a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\n     !"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\nsafe question mark: ?foo\nsafe colon: :foo\nsafe dash: -foo'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'safe: a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\n     !"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\nsafe question mark: ?foo\nsafe colon: :foo\nsafe dash: -foo'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FBC9'
yaml_content = 'safe: a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\n     !"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\nsafe question mark: ?foo\nsafe colon: :foo\nsafe dash: -foo'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'safe: a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\n     !"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\nsafe question mark: ?foo\nsafe colon: :foo\nsafe dash: -foo'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FBC9'
yaml_content = 'safe: a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\n     !"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\nsafe question mark: ?foo\nsafe colon: :foo\nsafe dash: -foo'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test FBC9: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[L9U5-implicit block key : [\n  implicit flow key : value,\n ]] _

source = 'implicit block key : [\n  implicit flow key : value,\n ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'implicit block key : [\n  implicit flow key : value,\n ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'L9U5'
yaml_content = 'implicit block key : [\n  implicit flow key : value,\n ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'implicit block key : [\n  implicit flow key : value,\n ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'L9U5'
yaml_content = 'implicit block key : [\n  implicit flow key : value,\n ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test L9U5: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[X8DW----\n? key\n# comment\n: value] _____________

source = '---\n? key\n# comment\n: value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n? key\n# comment\n: value'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'X8DW', yaml_content = '---\n? key\n# comment\n: value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n? key\n# comment\n: value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'X8DW', yaml_content = '---\n? key\n# comment\n: value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test X8DW: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
________ test_yaml_suite[S4GJ----\nfolded: > first line\n  second line] ________

source = '---\nfolded: > first line\n  second line'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nfolded: > first line\n  second line'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S4GJ', yaml_content = '---\nfolded: > first line\n  second line'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nfolded: > first line\n  second line'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S4GJ', yaml_content = '---\nfolded: > first line\n  second line'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test S4GJ: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_________________ test_yaml_suite[GH63-? a\n: 1.3\nfifteen: d] _________________

source = '? a\n: 1.3\nfifteen: d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '? a\n: 1.3\nfifteen: d'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'GH63', yaml_content = '? a\n: 1.3\nfifteen: d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '? a\n: 1.3\nfifteen: d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'GH63', yaml_content = '? a\n: 1.3\nfifteen: d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test GH63: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
______________________ test_yaml_suite[7W2P-? a\n? b\nc:] ______________________

source = '? a\n? b\nc:'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '? a\n? b\nc:'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '7W2P', yaml_content = '? a\n? b\nc:'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '? a\n? b\nc:'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '7W2P', yaml_content = '? a\n? b\nc:'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 7W2P: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[6LVF-%FOO  bar baz # Should be ignored\n              # with a warning.\n--- "foo"] _

source = '%FOO  bar baz # Should be ignored\n              # with a warning.\n--- "foo"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%FOO  bar baz # Should be ignored\n              # with a warning.\n--- "foo"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6LVF'
yaml_content = '%FOO  bar baz # Should be ignored\n              # with a warning.\n--- "foo"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%FOO  bar baz # Should be ignored\n              # with a warning.\n--- "foo"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6LVF'
yaml_content = '%FOO  bar baz # Should be ignored\n              # with a warning.\n--- "foo"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6LVF: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[4H7K----\n[ a, b, c ] ]] ___________________

source = '---\n[ a, b, c ] ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n[ a, b, c ] ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '4H7K', yaml_content = '---\n[ a, b, c ] ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n[ a, b, c ] ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '4H7K', yaml_content = '---\n[ a, b, c ] ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 4H7K: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[DBG4-# Outside flow collection:\n- ::vector\n- ": - ()"\n- Up, up, and away!\n- -123\n- http://example.com/foo#bar\n# Inside flow collection:\n- [ ::vector,\n  ": - ()",\n  "Up, up and away!",\n  -123,\n  http://example.com/foo#bar ]] _

source = '# Outside flow collection:\n- ::vector\n- ": - ()"\n- Up, up, and away!\n- -123\n- http://example.com/foo#bar\n# Inside flow collection:\n- [ ::vector,\n  ": - ()",\n  "Up, up and away!",\n  -123,\n  http://example.com/foo#bar ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Outside flow collection:\n- ::vector\n- ": - ()"\n- Up, up, and away!\n- -123\n- http://example.com/foo#bar\n# Inside flow collection:\n- [ ::vector,\n  ": - ()",\n  "Up, up and away!",\n  -123,\n  http://example.com/foo#bar ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DBG4'
yaml_content = '# Outside flow collection:\n- ::vector\n- ": - ()"\n- Up, up, and away!\n- -123\n- http://example.com/foo#bar\n# Inside flow collection:\n- [ ::vector,\n  ": - ()",\n  "Up, up and away!",\n  -123,\n  http://example.com/foo#bar ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Outside flow collection:\n- ::vector\n- ": - ()"\n- Up, up, and away!\n- -123\n- http://example.com/foo#bar\n# Inside flow collection:\n- [ ::vector,\n  ": - ()",\n  "Up, up and away!",\n  -123,\n  http://example.com/foo#bar ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DBG4'
yaml_content = '# Outside flow collection:\n- ::vector\n- ": - ()"\n- Up, up, and away!\n- -123\n- http://example.com/foo#bar\n# Inside flow collection:\n- [ ::vector,\n  ": - ()",\n  "Up, up and away!",\n  -123,\n  http://example.com/foo#bar ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test DBG4: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[NKF9----\nkey: value\n: empty key\n---\n{\n key: value, : empty key\n}\n---\n# empty key and value\n:\n---\n# empty key and value\n{ : }] _

source = '---\nkey: value\n: empty key\n---\n{\n key: value, : empty key\n}\n---\n# empty key and value\n:\n---\n# empty key and value\n{ : }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nkey: value\n: empty key\n---\n{\n key: value, : empty key\n}\n---\n# empty key and value\n:\n---\n# empty key and value\n{ : }'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NKF9'
yaml_content = '---\nkey: value\n: empty key\n---\n{\n key: value, : empty key\n}\n---\n# empty key and value\n:\n---\n# empty key and value\n{ : }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nkey: value\n: empty key\n---\n{\n key: value, : empty key\n}\n---\n# empty key and value\n:\n---\n# empty key and value\n{ : }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NKF9'
yaml_content = '---\nkey: value\n: empty key\n---\n{\n key: value, : empty key\n}\n---\n# empty key and value\n:\n---\n# empty key and value\n{ : }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test NKF9: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[6HB6-# Leading comment line spaces are\n # neither content nor indentation.] _

source = '# Leading comment line spaces are\n # neither content nor indentation.'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Leading comment line spaces are\n # neither content nor indentation.'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6HB6'
yaml_content = '# Leading comment line spaces are\n # neither content nor indentation.'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Leading comment line spaces are\n # neither content nor indentation.'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6HB6'
yaml_content = '# Leading comment line spaces are\n # neither content nor indentation.'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6HB6: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[U9NS----\ntime: 20:03:20\nplayer: Sammy Sosa\naction: strike (miss)\n...\n---\ntime: 20:03:47\nplayer: Sammy Sosa\naction: grand slam\n...] _

source = '---\ntime: 20:03:20\nplayer: Sammy Sosa\naction: strike (miss)\n...\n---\ntime: 20:03:47\nplayer: Sammy Sosa\naction: grand slam\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\ntime: 20:03:20\nplayer: Sammy Sosa\naction: strike (miss)\n...\n---\ntime: 20:03:47\nplayer: Sammy Sosa\naction: grand slam\n...'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'U9NS'
yaml_content = '---\ntime: 20:03:20\nplayer: Sammy Sosa\naction: strike (miss)\n...\n---\ntime: 20:03:47\nplayer: Sammy Sosa\naction: grand slam\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\ntime: 20:03:20\nplayer: Sammy Sosa\naction: strike (miss)\n...\n---\ntime: 20:03:47\nplayer: Sammy Sosa\naction: grand slam\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'U9NS'
yaml_content = '---\ntime: 20:03:20\nplayer: Sammy Sosa\naction: strike (miss)\n...\n---\ntime: 20:03:47\nplayer: Sammy Sosa\naction: grand slam\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test U9NS: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
___ test_yaml_suite[BF9H----\nplain: a\n       b # end of scalar\n       c] ____

source = '---\nplain: a\n       b # end of scalar\n       c'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nplain: a\n       b # end of scalar\n       c'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'BF9H'
yaml_content = '---\nplain: a\n       b # end of scalar\n       c'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nplain: a\n       b # end of scalar\n       c'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'BF9H'
yaml_content = '---\nplain: a\n       b # end of scalar\n       c'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test BF9H: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[RR7F-a: 4.2\n? d\n: 23] ____________________

source = 'a: 4.2\n? d\n: 23'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'a: 4.2\n? d\n: 23'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RR7F', yaml_content = 'a: 4.2\n? d\n: 23'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'a: 4.2\n? d\n: 23'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RR7F', yaml_content = 'a: 4.2\n? d\n: 23'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test RR7F: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_________ test_yaml_suite[AB8U-- single multiline\n - sequence entry] __________

source = '- single multiline\n - sequence entry'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- single multiline\n - sequence entry'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'AB8U', yaml_content = '- single multiline\n - sequence entry'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- single multiline\n - sequence entry'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'AB8U', yaml_content = '- single multiline\n - sequence entry'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test AB8U: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[SF5V-%YAML 1.2\n%YAML 1.2\n---] ________________

source = '%YAML 1.2\n%YAML 1.2\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML 1.2\n%YAML 1.2\n---'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SF5V', yaml_content = '%YAML 1.2\n%YAML 1.2\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML 1.2\n%YAML 1.2\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SF5V', yaml_content = '%YAML 1.2\n%YAML 1.2\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test SF5V: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[565N-canonical: !!binary "\\\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\\\n OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+\\\n +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC\\\n AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs="\ngeneric: !!binary |\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\n OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+\n +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC\n AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=\ndescription:\n The binary value above is a tiny arrow encoded as a gif image.] _

source = 'canonical: !!binary "\\\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\\\n OTk6enp56enmlpaWNjY6Ojo4...4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=\ndescription:\n The binary value above is a tiny arrow encoded as a gif image.'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'canonical: !!binary "\\\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\\\n OTk6enp56enmlpaWNjY6Ojo4...4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=\ndescription:\n The binary value above is a tiny arrow encoded as a gif image.'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '565N'
yaml_content = 'canonical: !!binary "\\\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\\\n OTk6enp56enmlpaWNjY6Ojo4...4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=\ndescription:\n The binary value above is a tiny arrow encoded as a gif image.'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'canonical: !!binary "\\\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\\\n OTk6enp56enmlpaWNjY6Ojo4...4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=\ndescription:\n The binary value above is a tiny arrow encoded as a gif image.'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '565N'
yaml_content = 'canonical: !!binary "\\\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\\\n OTk6enp56enmlpaWNjY6Ojo4...4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=\ndescription:\n The binary value above is a tiny arrow encoded as a gif image.'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 565N: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[87E4-'implicit block key' : [\n  'implicit flow key' : value,\n ]] _

source = "'implicit block key' : [\n  'implicit flow key' : value,\n ]"

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = "'implicit block key' : [\n  'implicit flow key' : value,\n ]"

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '87E4'
yaml_content = "'implicit block key' : [\n  'implicit flow key' : value,\n ]"

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = "'implicit block key' : [\n  'implicit flow key' : value,\n ]"

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '87E4'
yaml_content = "'implicit block key' : [\n  'implicit flow key' : value,\n ]"

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 87E4: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_________ test_yaml_suite[4HVU-key:\n   - ok\n   - also ok\n  - wrong] _________

source = 'key:\n   - ok\n   - also ok\n  - wrong'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key:\n   - ok\n   - also ok\n  - wrong'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '4HVU', yaml_content = 'key:\n   - ok\n   - also ok\n  - wrong'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key:\n   - ok\n   - also ok\n  - wrong'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '4HVU', yaml_content = 'key:\n   - ok\n   - also ok\n  - wrong'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 4HVU: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[6SLA-"foo\\nbar:baz\\tx \\\\$%^&*()x": 23\n'x\\ny:z\\tx $%^&*()x': 24] _

source = '"foo\\nbar:baz\\tx \\\\$%^&*()x": 23\n\'x\\ny:z\\tx $%^&*()x\': 24'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '"foo\\nbar:baz\\tx \\\\$%^&*()x": 23\n\'x\\ny:z\\tx $%^&*()x\': 24'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6SLA'
yaml_content = '"foo\\nbar:baz\\tx \\\\$%^&*()x": 23\n\'x\\ny:z\\tx $%^&*()x\': 24'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '"foo\\nbar:baz\\tx \\\\$%^&*()x": 23\n\'x\\ny:z\\tx $%^&*()x\': 24'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6SLA'
yaml_content = '"foo\\nbar:baz\\tx \\\\$%^&*()x": 23\n\'x\\ny:z\\tx $%^&*()x\': 24'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6SLA: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[SYW4-hr:  65    # Home runs\navg: 0.278 # Batting average\nrbi: 147   # Runs Batted In] _

source = 'hr:  65    # Home runs\navg: 0.278 # Batting average\nrbi: 147   # Runs Batted In'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'hr:  65    # Home runs\navg: 0.278 # Batting average\nrbi: 147   # Runs Batted In'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SYW4'
yaml_content = 'hr:  65    # Home runs\navg: 0.278 # Batting average\nrbi: 147   # Runs Batted In'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'hr:  65    # Home runs\navg: 0.278 # Batting average\nrbi: 147   # Runs Batted In'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SYW4'
yaml_content = 'hr:  65    # Home runs\navg: 0.278 # Batting average\nrbi: 147   # Runs Batted In'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test SYW4: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[JY7Z-key1: "quoted1"\nkey2: "quoted2" no key: nor value\nkey3: "quoted3"] _

source = 'key1: "quoted1"\nkey2: "quoted2" no key: nor value\nkey3: "quoted3"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key1: "quoted1"\nkey2: "quoted2" no key: nor value\nkey3: "quoted3"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JY7Z'
yaml_content = 'key1: "quoted1"\nkey2: "quoted2" no key: nor value\nkey3: "quoted3"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key1: "quoted1"\nkey2: "quoted2" no key: nor value\nkey3: "quoted3"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JY7Z'
yaml_content = 'key1: "quoted1"\nkey2: "quoted2" no key: nor value\nkey3: "quoted3"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test JY7Z: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
____ test_yaml_suite[EB22----\nscalar1 # comment\n%YAML 1.2\n---\nscalar2] _____

source = '---\nscalar1 # comment\n%YAML 1.2\n---\nscalar2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nscalar1 # comment\n%YAML 1.2\n---\nscalar2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'EB22'
yaml_content = '---\nscalar1 # comment\n%YAML 1.2\n---\nscalar2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nscalar1 # comment\n%YAML 1.2\n---\nscalar2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'EB22'
yaml_content = '---\nscalar1 # comment\n%YAML 1.2\n---\nscalar2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test EB22: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[AZW3-- bla"keks: foo\n- bla]keks: foo] ____________

source = '- bla"keks: foo\n- bla]keks: foo'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- bla"keks: foo\n- bla]keks: foo'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'AZW3', yaml_content = '- bla"keks: foo\n- bla]keks: foo'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- bla"keks: foo\n- bla]keks: foo'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'AZW3', yaml_content = '- bla"keks: foo\n- bla]keks: foo'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test AZW3: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[H2RW-foo: 1\n\nbar: 2\n\u2423\u2423\u2423\u2423\ntext: |\n  a\n\u2423\u2423\u2423\u2423\n  b\n\n  c\n\u2423\n  d] _

source = 'foo: 1\n\nbar: 2\nâ£â£â£â£\ntext: |\n  a\nâ£â£â£â£\n  b\n\n  c\nâ£\n  d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo: 1\n\nbar: 2\nâ£â£â£â£\ntext: |\n  a\nâ£â£â£â£\n  b\n\n  c\nâ£\n  d'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'H2RW'
yaml_content = 'foo: 1\n\nbar: 2\nâ£â£â£â£\ntext: |\n  a\nâ£â£â£â£\n  b\n\n  c\nâ£\n  d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'foo: 1\n\nbar: 2\nâ£â£â£â£\ntext: |\n  a\nâ£â£â£â£\n  b\n\n  c\nâ£\n  d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'H2RW'
yaml_content = 'foo: 1\n\nbar: 2\nâ£â£â£â£\ntext: |\n  a\nâ£â£â£â£\n  b\n\n  c\nâ£\n  d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test H2RW: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[TD5N-- item1\n- item2\ninvalid] ________________

source = '- item1\n- item2\ninvalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- item1\n- item2\ninvalid'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'TD5N', yaml_content = '- item1\n- item2\ninvalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- item1\n- item2\ninvalid'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'TD5N', yaml_content = '- item1\n- item2\ninvalid'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test TD5N: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[6JTT----\n[ [ a, b, c ]] ___________________

source = '---\n[ [ a, b, c ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n[ [ a, b, c ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6JTT', yaml_content = '---\n[ [ a, b, c ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n[ [ a, b, c ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6JTT', yaml_content = '---\n[ [ a, b, c ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6JTT: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[2AUY-- !!str a\n- b\n- !!int 42\n- d] _____________

source = '- !!str a\n- b\n- !!int 42\n- d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- !!str a\n- b\n- !!int 42\n- d'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '2AUY', yaml_content = '- !!str a\n- b\n- !!int 42\n- d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- !!str a\n- b\n- !!int 42\n- d'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '2AUY', yaml_content = '- !!str a\n- b\n- !!int 42\n- d'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 2AUY: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
___________ test_yaml_suite[EX5H----\na\nb\u2423\u2423\n  c\nd\n\ne] ___________

source = '---\na\nbâ£â£\n  c\nd\n\ne'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\na\nbâ£â£\n  c\nd\n\ne'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'EX5H', yaml_content = '---\na\nbâ£â£\n  c\nd\n\ne'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\na\nbâ£â£\n  c\nd\n\ne'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'EX5H', yaml_content = '---\na\nbâ£â£\n  c\nd\n\ne'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test EX5H: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[229Q--\n  name: Mark McGwire\n  hr:   65\n  avg:  0.278\n-\n  name: Sammy Sosa\n  hr:   63\n  avg:  0.288] _

source = '-\n  name: Mark McGwire\n  hr:   65\n  avg:  0.278\n-\n  name: Sammy Sosa\n  hr:   63\n  avg:  0.288'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '-\n  name: Mark McGwire\n  hr:   65\n  avg:  0.278\n-\n  name: Sammy Sosa\n  hr:   63\n  avg:  0.288'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '229Q'
yaml_content = '-\n  name: Mark McGwire\n  hr:   65\n  avg:  0.278\n-\n  name: Sammy Sosa\n  hr:   63\n  avg:  0.288'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '-\n  name: Mark McGwire\n  hr:   65\n  avg:  0.278\n-\n  name: Sammy Sosa\n  hr:   63\n  avg:  0.288'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '229Q'
yaml_content = '-\n  name: Mark McGwire\n  hr:   65\n  avg:  0.278\n-\n  name: Sammy Sosa\n  hr:   63\n  avg:  0.288'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 229Q: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
____ test_yaml_suite[93JH-- key: value\n  key2: value2\n-\n  key3: value3] _____

source = '- key: value\n  key2: value2\n-\n  key3: value3'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- key: value\n  key2: value2\n-\n  key3: value3'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '93JH'
yaml_content = '- key: value\n  key2: value2\n-\n  key3: value3'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- key: value\n  key2: value2\n-\n  key3: value3'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '93JH'
yaml_content = '- key: value\n  key2: value2\n-\n  key3: value3'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 93JH: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
________________________ test_yaml_suite[2JQS-: a\n: b] ________________________

source = ': a\n: b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = ': a\n: b'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '2JQS', yaml_content = ': a\n: b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = ': a\n: b'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '2JQS', yaml_content = ': a\n: b'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 2JQS: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[S9E8-sequence:\n- one\n- two\nmapping:\n  ? sky\n  : blue\n  sea : green] _

source = 'sequence:\n- one\n- two\nmapping:\n  ? sky\n  : blue\n  sea : green'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'sequence:\n- one\n- two\nmapping:\n  ? sky\n  : blue\n  sea : green'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S9E8'
yaml_content = 'sequence:\n- one\n- two\nmapping:\n  ? sky\n  : blue\n  sea : green'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'sequence:\n- one\n- two\nmapping:\n  ? sky\n  : blue\n  sea : green'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S9E8'
yaml_content = 'sequence:\n- one\n- two\nmapping:\n  ? sky\n  : blue\n  sea : green'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test S9E8: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_________ test_yaml_suite[5T43-- { "key":value }\n- { "key"::value }] __________

source = '- { "key":value }\n- { "key"::value }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- { "key":value }\n- { "key"::value }'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '5T43', yaml_content = '- { "key":value }\n- { "key"::value }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- { "key":value }\n- { "key"::value }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '5T43', yaml_content = '- { "key":value }\n- { "key"::value }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 5T43: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[GDY7-key: value\nthis is #not a: key] _____________

source = 'key: value\nthis is #not a: key'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key: value\nthis is #not a: key'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'GDY7', yaml_content = 'key: value\nthis is #not a: key'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key: value\nthis is #not a: key'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'GDY7', yaml_content = 'key: value\nthis is #not a: key'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test GDY7: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________________ test_yaml_suite[QF4Y-[\nfoo: bar\n]] _____________________

source = '[\nfoo: bar\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '[\nfoo: bar\n]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'QF4Y', yaml_content = '[\nfoo: bar\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '[\nfoo: bar\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'QF4Y', yaml_content = '[\nfoo: bar\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test QF4Y: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
__________________ test_yaml_suite[EXG3----\n---word1\nword2] __________________

source = '---\n---word1\nword2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n---word1\nword2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'EXG3', yaml_content = '---\n---word1\nword2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n---word1\nword2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'EXG3', yaml_content = '---\n---word1\nword2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test EXG3: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[DK4H----\n[ key\n  : value ]] _________________

source = '---\n[ key\n  : value ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n[ key\n  : value ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DK4H', yaml_content = '---\n[ key\n  : value ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n[ key\n  : value ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DK4H', yaml_content = '---\n[ key\n  : value ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test DK4H: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
____________________ test_yaml_suite[N782-[\n--- ,\n...\n]] ____________________

source = '[\n--- ,\n...\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '[\n--- ,\n...\n]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'N782', yaml_content = '[\n--- ,\n...\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '[\n--- ,\n...\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'N782', yaml_content = '[\n--- ,\n...\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test N782: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[BEC7-%YAML 1.3 # Attempt parsing\n          # with a warning\n---\n"foo"] _

source = '%YAML 1.3 # Attempt parsing\n          # with a warning\n---\n"foo"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML 1.3 # Attempt parsing\n          # with a warning\n---\n"foo"'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'BEC7'
yaml_content = '%YAML 1.3 # Attempt parsing\n          # with a warning\n---\n"foo"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML 1.3 # Attempt parsing\n          # with a warning\n---\n"foo"'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'BEC7'
yaml_content = '%YAML 1.3 # Attempt parsing\n          # with a warning\n---\n"foo"'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test BEC7: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[NAT4----\na: '\n  '\nb: '\u2423\u2423\n  '\nc: "\n  "\nd: "\u2423\u2423\n  "\ne: '\n\n  '\nf: "\n\n  "\ng: '\n\n\n  '\nh: "\n\n\n  "] _

source = '---\na: \'\n  \'\nb: \'â£â£\n  \'\nc: "\n  "\nd: "â£â£\n  "\ne: \'\n\n  \'\nf: "\n\n  "\ng: \'\n\n\n  \'\nh: "\n\n\n  "'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\na: \'\n  \'\nb: \'â£â£\n  \'\nc: "\n  "\nd: "â£â£\n  "\ne: \'\n\n  \'\nf: "\n\n  "\ng: \'\n\n\n  \'\nh: "\n\n\n  "'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 23: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NAT4'
yaml_content = '---\na: \'\n  \'\nb: \'â£â£\n  \'\nc: "\n  "\nd: "â£â£\n  "\ne: \'\n\n  \'\nf: "\n\n  "\ng: \'\n\n\n  \'\nh: "\n\n\n  "'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\na: \'\n  \'\nb: \'â£â£\n  \'\nc: "\n  "\nd: "â£â£\n  "\ne: \'\n\n  \'\nf: "\n\n  "\ng: \'\n\n\n  \'\nh: "\n\n\n  "'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 23: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'NAT4'
yaml_content = '---\na: \'\n  \'\nb: \'â£â£\n  \'\nc: "\n  "\nd: "â£â£\n  "\ne: \'\n\n  \'\nf: "\n\n  "\ng: \'\n\n\n  \'\nh: "\n\n\n  "'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test NAT4: Parser error: Parser error: Parse error at line 23: syntax error

tests/test_yaml_suite.py:88: Failed
___________________ test_yaml_suite[MUS6-%YAML 1.1#...\n---] ___________________

source = '%YAML 1.1#...\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML 1.1#...\n---'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'MUS6', yaml_content = '%YAML 1.1#...\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML 1.1#...\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'MUS6', yaml_content = '%YAML 1.1#...\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test MUS6: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
______________ test_yaml_suite[SR86-key1: &a value\nkey2: &b *a] _______________

source = 'key1: &a value\nkey2: &b *a'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key1: &a value\nkey2: &b *a'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SR86', yaml_content = 'key1: &a value\nkey2: &b *a'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key1: &a value\nkey2: &b *a'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SR86', yaml_content = 'key1: &a value\nkey2: &b *a'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test SR86: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
________ test_yaml_suite[9FMG-a:\n  b:\n    c: d\n  e:\n    f: g\nh: i] ________

source = 'a:\n  b:\n    c: d\n  e:\n    f: g\nh: i'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'a:\n  b:\n    c: d\n  e:\n    f: g\nh: i'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9FMG', yaml_content = 'a:\n  b:\n    c: d\n  e:\n    f: g\nh: i'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'a:\n  b:\n    c: d\n  e:\n    f: g\nh: i'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9FMG', yaml_content = 'a:\n  b:\n    c: d\n  e:\n    f: g\nh: i'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9FMG: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[P2AD-- | # Empty header\u2193\n literal\n- >1 # Indentation indicator\u2193\n  folded\n- |+ # Chomping indicator\u2193\n keep\n\n- >1- # Both indicators\u2193\n  strip] _

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- | # Empty headerâ†“\n literal\n- >1 # Indentation indicatorâ†“\n  folded\n- |+ # Chomping indicatorâ†“\n keep\n\n- >1- # Both indicatorsâ†“\n  strip'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557273.421414993, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = '- | # Empty headerâ†“\n literal\n- >1 # Indentation indicatorâ†“\n  folded\n- |+ # Chomping indicatorâ†“\n keep\n\n- >1- # Both indicatorsâ†“\n  strip'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- | # Empty headerâ†“\n literal\n- >1 # Indentation indicatorâ†“\n  folded\n- |+ # Chomping indicatorâ†“\n keep\n\n- >1- # Both indicatorsâ†“\n  strip'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = 'P2AD'
yaml_content = '- | # Empty headerâ†“\n literal\n- >1 # Indentation indicatorâ†“\n  folded\n- |+ # Chomping indicatorâ†“\n keep\n\n- >1- # Both indicatorsâ†“\n  strip'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- | # Empty headerâ†“\n literal\n- >1 # Indentation indicatorâ†“\n  folded\n- |+ # Chomping indicatorâ†“\n keep\n\n- >1- # Both indicatorsâ†“\n  strip'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'P2AD'
yaml_content = '- | # Empty headerâ†“\n literal\n- >1 # Indentation indicatorâ†“\n  folded\n- |+ # Chomping indicatorâ†“\n keep\n\n- >1- # Both indicatorsâ†“\n  strip'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test P2AD: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[735Y--\n  "flow in block"\n- >\n Block scalar\n- !!map # Block collection\n  foo : bar] _

source = '-\n  "flow in block"\n- >\n Block scalar\n- !!map # Block collection\n  foo : bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '-\n  "flow in block"\n- >\n Block scalar\n- !!map # Block collection\n  foo : bar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '735Y'
yaml_content = '-\n  "flow in block"\n- >\n Block scalar\n- !!map # Block collection\n  foo : bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '-\n  "flow in block"\n- >\n Block scalar\n- !!map # Block collection\n  foo : bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '735Y'
yaml_content = '-\n  "flow in block"\n- >\n Block scalar\n- !!map # Block collection\n  foo : bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 735Y: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_______ test_yaml_suite[JQ4R-block sequence:\n  - one\n  - two : three] ________

source = 'block sequence:\n  - one\n  - two : three'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'block sequence:\n  - one\n  - two : three'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JQ4R', yaml_content = 'block sequence:\n  - one\n  - two : three'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'block sequence:\n  - one\n  - two : three'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'JQ4R', yaml_content = 'block sequence:\n  - one\n  - two : three'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test JQ4R: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[CT4Q-[\n? foo\n bar : baz\n]] _________________

source = '[\n? foo\n bar : baz\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '[\n? foo\n bar : baz\n]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CT4Q', yaml_content = '[\n? foo\n bar : baz\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '[\n? foo\n bar : baz\n]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CT4Q', yaml_content = '[\n? foo\n bar : baz\n]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test CT4Q: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[7BUB----\nhr:\n  - Mark McGwire\n  # Following node labeled SS\n  - &SS Sammy Sosa\nrbi:\n  - *SS # Subsequent occurrence\n  - Ken Griffey] _

source = '---\nhr:\n  - Mark McGwire\n  # Following node labeled SS\n  - &SS Sammy Sosa\nrbi:\n  - *SS # Subsequent occurrence\n  - Ken Griffey'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nhr:\n  - Mark McGwire\n  # Following node labeled SS\n  - &SS Sammy Sosa\nrbi:\n  - *SS # Subsequent occurrence\n  - Ken Griffey'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '7BUB'
yaml_content = '---\nhr:\n  - Mark McGwire\n  # Following node labeled SS\n  - &SS Sammy Sosa\nrbi:\n  - *SS # Subsequent occurrence\n  - Ken Griffey'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nhr:\n  - Mark McGwire\n  # Following node labeled SS\n  - &SS Sammy Sosa\nrbi:\n  - *SS # Subsequent occurrence\n  - Ken Griffey'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '7BUB'
yaml_content = '---\nhr:\n  - Mark McGwire\n  # Following node labeled SS\n  - &SS Sammy Sosa\nrbi:\n  - *SS # Subsequent occurrence\n  - Ken Griffey'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 7BUB: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[XV9V-Folding:\n  "Empty line\n\n  as a line feed"\nChomping: |\n  Clipped empty lines\n\u2423\n\u21b5] _

source = 'Folding:\n  "Empty line\n\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'Folding:\n  "Empty line\n\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'XV9V'
yaml_content = 'Folding:\n  "Empty line\n\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'Folding:\n  "Empty line\n\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 5: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'XV9V'
yaml_content = 'Folding:\n  "Empty line\n\n  as a line feed"\nChomping: |\n  Clipped empty lines\nâ£\nâ†µ'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test XV9V: Parser error: Parser error: Parse error at line 5: syntax error

tests/test_yaml_suite.py:88: Failed
______________ test_yaml_suite[8XDJ-key: word1\n#  xxx\n  word2] _______________

source = 'key: word1\n#  xxx\n  word2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key: word1\n#  xxx\n  word2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '8XDJ', yaml_content = 'key: word1\n#  xxx\n  word2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key: word1\n#  xxx\n  word2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '8XDJ', yaml_content = 'key: word1\n#  xxx\n  word2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 8XDJ: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[HS5T-1st non-empty\n\n 2nd non-empty\u2423\n\u2014\u2014\u2014\xbb3rd non-empty] _

source = '1st non-empty\n\n 2nd non-emptyâ£\nâ€”â€”â€”Â»3rd non-empty'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '1st non-empty\n\n 2nd non-emptyâ£\nâ€”â€”â€”Â»3rd non-empty'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'HS5T'
yaml_content = '1st non-empty\n\n 2nd non-emptyâ£\nâ€”â€”â€”Â»3rd non-empty'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '1st non-empty\n\n 2nd non-emptyâ£\nâ€”â€”â€”Â»3rd non-empty'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'HS5T'
yaml_content = '1st non-empty\n\n 2nd non-emptyâ£\nâ€”â€”â€”Â»3rd non-empty'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test HS5T: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[96L6---- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury.] _

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = "--- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury."

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557278.562138396, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = "--- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury."

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = "--- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury."

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = '96L6'
yaml_content = "--- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury."

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = "--- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury."

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '96L6'
yaml_content = "--- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury."

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 96L6: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[7Z25----\nscalar1\n...\nkey: value] ______________

source = '---\nscalar1\n...\nkey: value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nscalar1\n...\nkey: value'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '7Z25', yaml_content = '---\nscalar1\n...\nkey: value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nscalar1\n...\nkey: value'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '7Z25', yaml_content = '---\nscalar1\n...\nkey: value'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 7Z25: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_________________ test_yaml_suite[KMK3-foo:\n  bar: 1\nbaz: 2] _________________

source = 'foo:\n  bar: 1\nbaz: 2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo:\n  bar: 1\nbaz: 2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'KMK3', yaml_content = 'foo:\n  bar: 1\nbaz: 2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'foo:\n  bar: 1\nbaz: 2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'KMK3', yaml_content = 'foo:\n  bar: 1\nbaz: 2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test KMK3: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_______ test_yaml_suite[CFD4-- [ : empty key ]\n- [: another empty key]] _______

source = '- [ : empty key ]\n- [: another empty key]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- [ : empty key ]\n- [: another empty key]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CFD4', yaml_content = '- [ : empty key ]\n- [: another empty key]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- [ : empty key ]\n- [: another empty key]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'CFD4', yaml_content = '- [ : empty key ]\n- [: another empty key]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test CFD4: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[9MMW-- [ YAML : separate ]\n- [ "JSON like":adjacent ]\n- [ {JSON: like}:adjacent ]] _

source = '- [ YAML : separate ]\n- [ "JSON like":adjacent ]\n- [ {JSON: like}:adjacent ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '- [ YAML : separate ]\n- [ "JSON like":adjacent ]\n- [ {JSON: like}:adjacent ]'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9MMW'
yaml_content = '- [ YAML : separate ]\n- [ "JSON like":adjacent ]\n- [ {JSON: like}:adjacent ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '- [ YAML : separate ]\n- [ "JSON like":adjacent ]\n- [ {JSON: like}:adjacent ]'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9MMW'
yaml_content = '- [ YAML : separate ]\n- [ "JSON like":adjacent ]\n- [ {JSON: like}:adjacent ]'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9MMW: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_____________________ test_yaml_suite[PUW8----\na: b\n---] _____________________

source = '---\na: b\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\na: b\n---'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'PUW8', yaml_content = '---\na: b\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\na: b\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'PUW8', yaml_content = '---\na: b\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test PUW8: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
________________ test_yaml_suite[RLU9-foo:\n- 42\nbar:\n  - 44] ________________

source = 'foo:\n- 42\nbar:\n  - 44'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo:\n- 42\nbar:\n  - 44'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RLU9', yaml_content = 'foo:\n- 42\nbar:\n  - 44'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'foo:\n- 42\nbar:\n  - 44'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'RLU9', yaml_content = 'foo:\n- 42\nbar:\n  - 44'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test RLU9: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[P76L-%TAG !! tag:example.com,2000:app/\n---\n!!int 1 - 3 # Interval, not integer] _

source = '%TAG !! tag:example.com,2000:app/\n---\n!!int 1 - 3 # Interval, not integer'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%TAG !! tag:example.com,2000:app/\n---\n!!int 1 - 3 # Interval, not integer'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'P76L'
yaml_content = '%TAG !! tag:example.com,2000:app/\n---\n!!int 1 - 3 # Interval, not integer'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%TAG !! tag:example.com,2000:app/\n---\n!!int 1 - 3 # Interval, not integer'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'P76L'
yaml_content = '%TAG !! tag:example.com,2000:app/\n---\n!!int 1 - 3 # Interval, not integer'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test P76L: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[6CK3-%TAG !e! tag:example.com,2000:app/\n---\n- !local foo\n- !!str bar\n- !e!tag%21 baz] _

source = '%TAG !e! tag:example.com,2000:app/\n---\n- !local foo\n- !!str bar\n- !e!tag%21 baz'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%TAG !e! tag:example.com,2000:app/\n---\n- !local foo\n- !!str bar\n- !e!tag%21 baz'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '6CK3'
yaml_content = '%TAG !e! tag:example.com,2000:app/\n---\n- !local foo\n- !!str bar\n- !e!tag%21 baz'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%TAG !e! tag:example.com,2000:app/\n---\n- !local foo\n- !!str bar\n- !e!tag%21 baz'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '6CK3'
yaml_content = '%TAG !e! tag:example.com,2000:app/\n---\n- !local foo\n- !!str bar\n- !e!tag%21 baz'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 6CK3: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________ test_yaml_suite[2SXE-&a: key: &a value\nfoo:\n  *a:] _____________

source = '&a: key: &a value\nfoo:\n  *a:'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '&a: key: &a value\nfoo:\n  *a:'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '2SXE', yaml_content = '&a: key: &a value\nfoo:\n  *a:'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '&a: key: &a value\nfoo:\n  *a:'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '2SXE', yaml_content = '&a: key: &a value\nfoo:\n  *a:'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 2SXE: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[2EBW-a!"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~: safe\n?foo: safe question mark\n:foo: safe colon\n-foo: safe dash\nthis is#not: a comment] _

source = 'a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~: safe\n?foo: safe question mark\n:foo: safe colon\n-foo: safe dash\nthis is#not: a comment'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~: safe\n?foo: safe question mark\n:foo: safe colon\n-foo: safe dash\nthis is#not: a comment'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '2EBW'
yaml_content = 'a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~: safe\n?foo: safe question mark\n:foo: safe colon\n-foo: safe dash\nthis is#not: a comment'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~: safe\n?foo: safe question mark\n:foo: safe colon\n-foo: safe dash\nthis is#not: a comment'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '2EBW'
yaml_content = 'a!"#$%&\'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~: safe\n?foo: safe question mark\n:foo: safe colon\n-foo: safe dash\nthis is#not: a comment'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 2EBW: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[4ZYM-plain: text\n  lines\nquoted: "text\n  \u2014\xbblines"\nblock: |\n  text\n   \xbblines] _

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'plain: text\n  lines\nquoted: "text\n  â€”Â»lines"\nblock: |\n  text\n   Â»lines'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557283.76636523, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = 'plain: text\n  lines\nquoted: "text\n  â€”Â»lines"\nblock: |\n  text\n   Â»lines'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'plain: text\n  lines\nquoted: "text\n  â€”Â»lines"\nblock: |\n  text\n   Â»lines'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = '4ZYM'
yaml_content = 'plain: text\n  lines\nquoted: "text\n  â€”Â»lines"\nblock: |\n  text\n   Â»lines'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'plain: text\n  lines\nquoted: "text\n  â€”Â»lines"\nblock: |\n  text\n   Â»lines'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '4ZYM'
yaml_content = 'plain: text\n  lines\nquoted: "text\n  â€”Â»lines"\nblock: |\n  text\n   Â»lines'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 4ZYM: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
________ test_yaml_suite[SU74-key1: &alias value1\n&b *alias : value2] _________

source = 'key1: &alias value1\n&b *alias : value2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'key1: &alias value1\n&b *alias : value2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SU74', yaml_content = 'key1: &alias value1\n&b *alias : value2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'key1: &alias value1\n&b *alias : value2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'SU74', yaml_content = 'key1: &alias value1\n&b *alias : value2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test SU74: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[J7PZ-# The !!omap tag is one of the optional types\n# introduced for YAML 1.1. In 1.2, it is not\n# part of the standard tags and should not be\n# enabled by default.\n# Ordered maps are represented as\n# A sequence of mappings, with\n# each mapping having one key\n--- !!omap\n- Mark McGwire: 65\n- Sammy Sosa: 63\n- Ken Griffy: 58] _

source = '# The !!omap tag is one of the optional types\n# introduced for YAML 1.1. In 1.2, it is not\n# part of the standard t...e of mappings, with\n# each mapping having one key\n--- !!omap\n- Mark McGwire: 65\n- Sammy Sosa: 63\n- Ken Griffy: 58'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# The !!omap tag is one of the optional types\n# introduced for YAML 1.1. In 1.2, it is not\n# part of the standard t...e of mappings, with\n# each mapping having one key\n--- !!omap\n- Mark McGwire: 65\n- Sammy Sosa: 63\n- Ken Griffy: 58'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 8: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J7PZ'
yaml_content = '# The !!omap tag is one of the optional types\n# introduced for YAML 1.1. In 1.2, it is not\n# part of the standard t...e of mappings, with\n# each mapping having one key\n--- !!omap\n- Mark McGwire: 65\n- Sammy Sosa: 63\n- Ken Griffy: 58'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# The !!omap tag is one of the optional types\n# introduced for YAML 1.1. In 1.2, it is not\n# part of the standard t...e of mappings, with\n# each mapping having one key\n--- !!omap\n- Mark McGwire: 65\n- Sammy Sosa: 63\n- Ken Griffy: 58'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 8: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J7PZ'
yaml_content = '# The !!omap tag is one of the optional types\n# introduced for YAML 1.1. In 1.2, it is not\n# part of the standard t...e of mappings, with\n# each mapping having one key\n--- !!omap\n- Mark McGwire: 65\n- Sammy Sosa: 63\n- Ken Griffy: 58'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test J7PZ: Parser error: Parser error: Parse error at line 8: syntax error

tests/test_yaml_suite.py:88: Failed
_____________________ test_yaml_suite[S4T7-aaa: bbb\n...] ______________________

source = 'aaa: bbb\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'aaa: bbb\n...'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S4T7', yaml_content = 'aaa: bbb\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'aaa: bbb\n...'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S4T7', yaml_content = 'aaa: bbb\n...'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test S4T7: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____________________ test_yaml_suite[ZYU8-%YAML1.1\n---] ______________________

source = '%YAML1.1\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%YAML1.1\n---'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZYU8', yaml_content = '%YAML1.1\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%YAML1.1\n---'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'ZYU8', yaml_content = '%YAML1.1\n---'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test ZYU8: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_____ test_yaml_suite[7FWL-!<tag:yaml.org,2002:str> foo :\n  !<!bar> baz] ______

source = '!<tag:yaml.org,2002:str> foo :\n  !<!bar> baz'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '!<tag:yaml.org,2002:str> foo :\n  !<!bar> baz'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '7FWL', yaml_content = '!<tag:yaml.org,2002:str> foo :\n  !<!bar> baz'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '!<tag:yaml.org,2002:str> foo :\n  !<!bar> baz'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 1: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '7FWL', yaml_content = '!<tag:yaml.org,2002:str> foo :\n  !<!bar> baz'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 7FWL: Parser error: Parser error: Parse error at line 1: syntax error

tests/test_yaml_suite.py:88: Failed
___________ test_yaml_suite[9KBC---- key1: value1\n    key2: value2] ___________

source = '--- key1: value1\n    key2: value2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '--- key1: value1\n    key2: value2'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '9KBC', yaml_content = '--- key1: value1\n    key2: value2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '--- key1: value1\n    key2: value2'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '9KBC', yaml_content = '--- key1: value1\n    key2: value2'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 9KBC: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[T833----\n{\n foo: 1\n bar: 2 }] _______________

source = '---\n{\n foo: 1\n bar: 2 }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\n{\n foo: 1\n bar: 2 }'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'T833', yaml_content = '---\n{\n foo: 1\n bar: 2 }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\n{\n foo: 1\n bar: 2 }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'T833', yaml_content = '---\n{\n foo: 1\n bar: 2 }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test T833: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[7ZZ5----\nnested sequences:\n- - - []\n- - - {}\nkey1: []\nkey2: {}] _

source = '---\nnested sequences:\n- - - []\n- - - {}\nkey1: []\nkey2: {}'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\nnested sequences:\n- - - []\n- - - {}\nkey1: []\nkey2: {}'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '7ZZ5'
yaml_content = '---\nnested sequences:\n- - - []\n- - - {}\nkey1: []\nkey2: {}'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\nnested sequences:\n- - - []\n- - - {}\nkey1: []\nkey2: {}'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '7ZZ5'
yaml_content = '---\nnested sequences:\n- - - []\n- - - {}\nkey1: []\nkey2: {}'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 7ZZ5: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[U3XV----\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4:\n  &node4\n  &k4 key4: four\ntop5:\n  &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven] _

source = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4:\n  &node4\n  &k4 key4: four\ntop5:\n  &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4:\n  &node4\n  &k4 key4: four\ntop5:\n  &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'U3XV'
yaml_content = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4:\n  &node4\n  &k4 key4: four\ntop5:\n  &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4:\n  &node4\n  &k4 key4: four\ntop5:\n  &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'U3XV'
yaml_content = '---\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4:\n  &node4\n  &k4 key4: four\ntop5:\n  &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test U3XV: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_______________ test_yaml_suite[FP8R---- >\nline1\nline2\nline3] _______________

source = '--- >\nline1\nline2\nline3'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '--- >\nline1\nline2\nline3'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FP8R', yaml_content = '--- >\nline1\nline2\nline3'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '--- >\nline1\nline2\nline3'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'FP8R', yaml_content = '--- >\nline1\nline2\nline3'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test FP8R: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[35KP---- !!map\n? a\n: b\n--- !!seq\n- !!str c\n--- !!str\nd\ne] _

source = '--- !!map\n? a\n: b\n--- !!seq\n- !!str c\n--- !!str\nd\ne'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '--- !!map\n? a\n: b\n--- !!seq\n- !!str c\n--- !!str\nd\ne'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '35KP'
yaml_content = '--- !!map\n? a\n: b\n--- !!seq\n- !!str c\n--- !!str\nd\ne'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '--- !!map\n? a\n: b\n--- !!seq\n- !!str c\n--- !!str\nd\ne'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 3: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '35KP'
yaml_content = '--- !!map\n? a\n: b\n--- !!seq\n- !!str c\n--- !!str\nd\ne'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 35KP: Parser error: Parser error: Parse error at line 3: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[S3PD-plain key: in-line value\n: # Both empty\n"quoted key":\n- entry] _

source = 'plain key: in-line value\n: # Both empty\n"quoted key":\n- entry'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'plain key: in-line value\n: # Both empty\n"quoted key":\n- entry'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S3PD'
yaml_content = 'plain key: in-line value\n: # Both empty\n"quoted key":\n- entry'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'plain key: in-line value\n: # Both empty\n"quoted key":\n- entry'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'S3PD'
yaml_content = 'plain key: in-line value\n: # Both empty\n"quoted key":\n- entry'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test S3PD: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
____________ test_yaml_suite[DK95-foo:\n \u2014\u2014\u2014\xbbbar] ____________

source = 'foo:\n â€”â€”â€”Â»bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'foo:\n â€”â€”â€”Â»bar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DK95', yaml_content = 'foo:\n â€”â€”â€”Â»bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'foo:\n â€”â€”â€”Â»bar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'DK95', yaml_content = 'foo:\n â€”â€”â€”Â»bar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test DK95: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[QLJ7-%TAG !prefix! tag:example.com,2011:\n--- !prefix!A\na: b\n--- !prefix!B\nc: d\n--- !prefix!C\ne: f] _

source = '%TAG !prefix! tag:example.com,2011:\n--- !prefix!A\na: b\n--- !prefix!B\nc: d\n--- !prefix!C\ne: f'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%TAG !prefix! tag:example.com,2011:\n--- !prefix!A\na: b\n--- !prefix!B\nc: d\n--- !prefix!C\ne: f'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'QLJ7'
yaml_content = '%TAG !prefix! tag:example.com,2011:\n--- !prefix!A\na: b\n--- !prefix!B\nc: d\n--- !prefix!C\ne: f'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%TAG !prefix! tag:example.com,2011:\n--- !prefix!A\na: b\n--- !prefix!B\nc: d\n--- !prefix!C\ne: f'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'QLJ7'
yaml_content = '%TAG !prefix! tag:example.com,2011:\n--- !prefix!A\na: b\n--- !prefix!B\nc: d\n--- !prefix!C\ne: f'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test QLJ7: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
______________ test_yaml_suite[X4QW-block: ># comment\n  scalar] _______________

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'block: ># comment\n  scalar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
>           result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )

lib/computer/yaml/parser_bridge.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../miniconda3/lib/python3.13/subprocess.py:556: in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:1222: in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../miniconda3/lib/python3.13/subprocess.py:2129: in _communicate
    self._check_timeout(endtime, orig_timeout, stdout, stderr)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: -9 args: ['/home/colltoaction/GitHub/widip/lib/yaml/_yam...>
endtime = 557288.973161187, orig_timeout = 5, stdout_seq = [], stderr_seq = []
skip_check_and_raise = False

    def _check_timeout(self, endtime, orig_timeout, stdout_seq, stderr_seq,
                       skip_check_and_raise=False):
        """Convenience for checking if a timeout has expired."""
        if endtime is None:
            return
        if skip_check_and_raise or _time() > endtime:
>           raise TimeoutExpired(
                    self.args, orig_timeout,
                    output=b''.join(stdout_seq) if stdout_seq else None,
                    stderr=b''.join(stderr_seq) if stderr_seq else None)
E           subprocess.TimeoutExpired: Command '['/home/colltoaction/GitHub/widip/lib/yaml/_yaml_parser']' timed out after 5 seconds

../../miniconda3/lib/python3.13/subprocess.py:1269: TimeoutExpired

During handling of the above exception, another exception occurred:

source = 'block: ># comment\n  scalar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'block: ># comment\n  scalar'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
                raise ValueError(f"Parser error: {error_msg}")
    
            # Parse the output (currently prints AST, we'd need to modify to output JSON)
            output = result.stdout.decode('utf-8')
            return self._parse_ast_output(output)
    
        except subprocess.TimeoutExpired:
>           raise TimeoutError("Parser timed out")
E           TimeoutError: Parser timed out

lib/computer/yaml/parser_bridge.py:76: TimeoutError

During handling of the above exception, another exception occurred:

test_id = 'X4QW', yaml_content = 'block: ># comment\n  scalar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'block: ># comment\n  scalar'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser timed out

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'X4QW', yaml_content = 'block: ># comment\n  scalar'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test X4QW: Parser error: Parser timed out

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[XW4D-a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne:\n &node # lala\n - x: y\nblock: > # lala\n  abcde] _

source = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne:\n &node # lala\n - x: y\nblock: > # lala\n  abcde'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne:\n &node # lala\n - x: y\nblock: > # lala\n  abcde'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 7: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'XW4D'
yaml_content = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne:\n &node # lala\n - x: y\nblock: > # lala\n  abcde'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne:\n &node # lala\n - x: y\nblock: > # lala\n  abcde'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 7: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'XW4D'
yaml_content = 'a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne:\n &node # lala\n - x: y\nblock: > # lala\n  abcde'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test XW4D: Parser error: Parser error: Parse error at line 7: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[5TYM-%TAG !m! !my-\n--- # Bulb here\n!m!light fluorescent\n...\n%TAG !m! !my-\n--- # Color here\n!m!light green] _

source = '%TAG !m! !my-\n--- # Bulb here\n!m!light fluorescent\n...\n%TAG !m! !my-\n--- # Color here\n!m!light green'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%TAG !m! !my-\n--- # Bulb here\n!m!light fluorescent\n...\n%TAG !m! !my-\n--- # Color here\n!m!light green'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '5TYM'
yaml_content = '%TAG !m! !my-\n--- # Bulb here\n!m!light fluorescent\n...\n%TAG !m! !my-\n--- # Color here\n!m!light green'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%TAG !m! !my-\n--- # Bulb here\n!m!light fluorescent\n...\n%TAG !m! !my-\n--- # Color here\n!m!light green'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '5TYM'
yaml_content = '%TAG !m! !my-\n--- # Bulb here\n!m!light fluorescent\n...\n%TAG !m! !my-\n--- # Color here\n!m!light green'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 5TYM: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[2XXW-# Sets are represented as a\n# Mapping where each key is\n# associated with a null value\n--- !!set\n? Mark McGwire\n? Sammy Sosa\n? Ken Griff] _

source = '# Sets are represented as a\n# Mapping where each key is\n# associated with a null value\n--- !!set\n? Mark McGwire\n? Sammy Sosa\n? Ken Griff'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Sets are represented as a\n# Mapping where each key is\n# associated with a null value\n--- !!set\n? Mark McGwire\n? Sammy Sosa\n? Ken Griff'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = '2XXW'
yaml_content = '# Sets are represented as a\n# Mapping where each key is\n# associated with a null value\n--- !!set\n? Mark McGwire\n? Sammy Sosa\n? Ken Griff'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Sets are represented as a\n# Mapping where each key is\n# associated with a null value\n--- !!set\n? Mark McGwire\n? Sammy Sosa\n? Ken Griff'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = '2XXW'
yaml_content = '# Sets are represented as a\n# Mapping where each key is\n# associated with a null value\n--- !!set\n? Mark McGwire\n? Sammy Sosa\n? Ken Griff'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test 2XXW: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[C4HZ-%TAG ! tag:clarkevans.com,2002:\n--- !shape\n  # Use the ! handle for presenting\n  # tag:clarkevans.com,2002:circle\n- !circle\n  center: &ORIGIN {x: 73, y: 129}\n  radius: 7\n- !line\n  start: *ORIGIN\n  finish: { x: 89, y: 102 }\n- !label\n  start: *ORIGIN\n  color: 0xFFEEBB\n  text: Pretty vector drawing.] _

source = '%TAG ! tag:clarkevans.com,2002:\n--- !shape\n  # Use the ! handle for presenting\n  # tag:clarkevans.com,2002:circle\...t: *ORIGIN\n  finish: { x: 89, y: 102 }\n- !label\n  start: *ORIGIN\n  color: 0xFFEEBB\n  text: Pretty vector drawing.'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '%TAG ! tag:clarkevans.com,2002:\n--- !shape\n  # Use the ! handle for presenting\n  # tag:clarkevans.com,2002:circle\...t: *ORIGIN\n  finish: { x: 89, y: 102 }\n- !label\n  start: *ORIGIN\n  color: 0xFFEEBB\n  text: Pretty vector drawing.'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'C4HZ'
yaml_content = '%TAG ! tag:clarkevans.com,2002:\n--- !shape\n  # Use the ! handle for presenting\n  # tag:clarkevans.com,2002:circle\...t: *ORIGIN\n  finish: { x: 89, y: 102 }\n- !label\n  start: *ORIGIN\n  color: 0xFFEEBB\n  text: Pretty vector drawing.'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '%TAG ! tag:clarkevans.com,2002:\n--- !shape\n  # Use the ! handle for presenting\n  # tag:clarkevans.com,2002:circle\...t: *ORIGIN\n  finish: { x: 89, y: 102 }\n- !label\n  start: *ORIGIN\n  color: 0xFFEEBB\n  text: Pretty vector drawing.'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 4: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'C4HZ'
yaml_content = '%TAG ! tag:clarkevans.com,2002:\n--- !shape\n  # Use the ! handle for presenting\n  # tag:clarkevans.com,2002:circle\...t: *ORIGIN\n  finish: { x: 89, y: 102 }\n- !label\n  start: *ORIGIN\n  color: 0xFFEEBB\n  text: Pretty vector drawing.'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test C4HZ: Parser error: Parser error: Parse error at line 4: syntax error

tests/test_yaml_suite.py:88: Failed
_ test_yaml_suite[J3BT-# Tabs and spaces\nquoted: "Quoted \u2014\u2014\u2014\xbb"\nblock:\u2014\xbb|\n  void main() {\n  \u2014\xbbprintf("Hello, world!\\n");\n  }] _

source = '# Tabs and spaces\nquoted: "Quoted â€”â€”â€”Â»"\nblock:â€”Â»|\n  void main() {\n  â€”Â»printf("Hello, world!\\n");\n  }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
>               return parser.parse(source_str)
                       ^^^^^^^^^^^^^^^^^^^^^^^^

lib/computer/yaml/parse.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/parser_bridge.py:252: in parse
    ast = self.parse_to_ast(yaml_source)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <computer.yaml.parser_bridge.YAMLParserBridge object at 0x7f89462a8ad0>
yaml_source = '# Tabs and spaces\nquoted: "Quoted â€”â€”â€”Â»"\nblock:â€”Â»|\n  void main() {\n  â€”Â»printf("Hello, world!\\n");\n  }'

    def parse_to_ast(self, yaml_source: str) -> dict:
        """
        Parse YAML source to AST using the C parser.
    
        Args:
            yaml_source: YAML source code as string
    
        Returns:
            AST as a dictionary
        """
        # Run the parser as a subprocess
        try:
            result = subprocess.run(
                [self.parser_path],
                input=yaml_source.encode('utf-8'),
                capture_output=True,
                timeout=5
            )
    
            if result.returncode != 0:
                error_msg = result.stderr.decode('utf-8')
>               raise ValueError(f"Parser error: {error_msg}")
E               ValueError: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parser_bridge.py:69: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J3BT'
yaml_content = '# Tabs and spaces\nquoted: "Quoted â€”â€”â€”Â»"\nblock:â€”Â»|\n  void main() {\n  â€”Â»printf("Hello, world!\\n");\n  }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
>           diag = load(yaml_content)
                   ^^^^^^^^^^^^^^^^^^

tests/test_yaml_suite.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
lib/computer/yaml/__init__.py:109: in <lambda>
    load = lambda source: construct_functor(compose_functor(impl_parse(source)))
                                                            ^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

source = '# Tabs and spaces\nquoted: "Quoted â€”â€”â€”Â»"\nblock:â€”Â»|\n  void main() {\n  â€”Â»printf("Hello, world!\\n");\n  }'

    def impl_parse(source) -> closed.Diagram:
        """
        Native implementation of the YAML parser using C lex/yacc.
    
        This replaces the old nx_yaml implementation with the compiled parser,
        enabling metacompilation and supercompilation.
        """
        # Extract source string
        if hasattr(source, "source") and type(source).__name__ == "CharacterStream":
            source = source.source
    
        if not hasattr(source, 'read') and not isinstance(source, (str, bytes)):
            raise TypeError(f"Expected stream or string, got {type(source)}")
    
        # Convert to string if needed
        if hasattr(source, 'read'):
            source_str = source.read()
            if isinstance(source_str, bytes):
                source_str = source_str.decode('utf-8')
        elif isinstance(source, bytes):
            source_str = source.decode('utf-8')
        else:
            source_str = str(source)
    
        # Try C parser
        parser = get_parser()
        if parser is not None:
            try:
                return parser.parse(source_str)
            except Exception as e:
>               raise ValueError(f"Parser error: {e}")
E               ValueError: Parser error: Parser error: Parse error at line 2: syntax error

lib/computer/yaml/parse.py:71: ValueError

During handling of the above exception, another exception occurred:

test_id = 'J3BT'
yaml_content = '# Tabs and spaces\nquoted: "Quoted â€”â€”â€”Â»"\nblock:â€”Â»|\n  void main() {\n  â€”Â»printf("Hello, world!\\n");\n  }'

    @pytest.mark.parametrize("test_id, yaml_content", get_test_cases())
    def test_yaml_suite(test_id, yaml_content):
        """Run a test case from the YAML Test Suite."""
        try:
            # We only check if it executes/parses without crashing for now.
            # Validating output structure against the suite's 'json' or 'tree' is harder
            # because our AST structure is custom (DisCoPy diagrams).
    
            diag = load(yaml_content)
            assert diag is not None
    
        except Exception as e:
>           pytest.fail(f"Failed to parse/load test {test_id}: {e}")
E           Failed: Failed to parse/load test J3BT: Parser error: Parser error: Parse error at line 2: syntax error

tests/test_yaml_suite.py:88: Failed
=========================== short test summary info ============================
FAILED tests/test_yaml_suite.py::test_yaml_suite[M5C3-literal: |2\n  value\nfolded:\n   !foo\n  >1\n value]
FAILED tests/test_yaml_suite.py::test_yaml_suite[3HFZ----\nkey: value\n... invalid]
FAILED tests/test_yaml_suite.py::test_yaml_suite[57H4-sequence: !!seq\n- entry\n- !!seq\n - nested\nmapping: !!map\n foo: bar]
FAILED tests/test_yaml_suite.py::test_yaml_suite[A6F9-strip: |-\n  text\nclip: |\n  text\nkeep: |+\n  text]
FAILED tests/test_yaml_suite.py::test_yaml_suite[K3WX----\n{ "foo" # comment\n  :bar }]
FAILED tests/test_yaml_suite.py::test_yaml_suite[DMG6-key:\n  ok: 1\n wrong: 2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[SKE5----\nseq:\n &anchor\n- a\n- b]
FAILED tests/test_yaml_suite.py::test_yaml_suite[ZH7C-&a a: b\nc: &d d] - Fai...
FAILED tests/test_yaml_suite.py::test_yaml_suite[9CWY-key:\n - item1\n - item2\ninvalid]
FAILED tests/test_yaml_suite.py::test_yaml_suite[96NN-foo: |-\n \u2014\u2014\xbbbar]
FAILED tests/test_yaml_suite.py::test_yaml_suite[G9HC----\nseq:\n&anchor\n- a\n- b]
FAILED tests/test_yaml_suite.py::test_yaml_suite[P94K-key:    # Comment\n        # lines\n  value\n\u21b5\n\u21b5]
FAILED tests/test_yaml_suite.py::test_yaml_suite[C2DT-{\n"adjacent":value,\n"readable": value,\n"empty":\n}]
FAILED tests/test_yaml_suite.py::test_yaml_suite[3GZX-First occurrence: &anchor Foo\nSecond occurrence: *anchor\nOverride anchor: &anchor Bar\nReuse anchor: *anchor]
FAILED tests/test_yaml_suite.py::test_yaml_suite[V55R-- &a a\n- &b b\n- *a\n- *b]
FAILED tests/test_yaml_suite.py::test_yaml_suite[27NA-%YAML 1.2\n--- text] - ...
FAILED tests/test_yaml_suite.py::test_yaml_suite[Q9WF-{ first: Sammy, last: Sosa }:\n# Statistics:\n  hr:  # Home runs\n     65\n  avg: # Average\n   0.278]
FAILED tests/test_yaml_suite.py::test_yaml_suite[NP9H-"folded\u2423\nto a space,\xbb\n\u2423\nto a line feed, or \xbb\\\n \\ \xbbnon-content"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[4JVG-top1: &node1\n  &k1 key1: val1\ntop2: &node2\n  &v2 val2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[BS4K-word1  # comment\nword2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[K858-strip: >-\n\nclip: >\n\nkeep: |+\n\u21b5]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9WXW-# Private\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[5U3A-key: - a\n     - b] - F...
FAILED tests/test_yaml_suite.py::test_yaml_suite[6ZKB-Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20]
FAILED tests/test_yaml_suite.py::test_yaml_suite[L94M-? !!str a\n: !!int 47\n? c\n: !!str d]
FAILED tests/test_yaml_suite.py::test_yaml_suite[3ALJ-- - s1_i1\n  - s1_i2\n- s2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[4WA9-- aaa: |2\n    xxx\n  bbb: |\n    xxx]
FAILED tests/test_yaml_suite.py::test_yaml_suite[CUP7-anchored: !local &anchor value\nalias: *anchor]
FAILED tests/test_yaml_suite.py::test_yaml_suite[8QBE-key:\n - item1\n - item2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[5MUD----\n{ "foo"\n  :bar }]
FAILED tests/test_yaml_suite.py::test_yaml_suite[ZWK4----\na: 1\n? b\n&anchor c: 3]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6S55-key:\n - bar\n - baz\n invalid]
FAILED tests/test_yaml_suite.py::test_yaml_suite[RZP5-a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne: &node # lala\n - x: y\nblock: > # lala\n  abcde]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6WLZ-# Private\n---\n!foo "bar"\n...\n# Global\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[L383---- foo  # comment\n--- foo  # comment]
FAILED tests/test_yaml_suite.py::test_yaml_suite[AZ63-one:\n- 2\n- 3\nfour: 5]
FAILED tests/test_yaml_suite.py::test_yaml_suite[74H7-!!str a: b\nc: !!int 42\ne: !!str f\ng: h\n!!str 23: !!bool false]
FAILED tests/test_yaml_suite.py::test_yaml_suite[JS2J-First occurrence: &anchor Value\nSecond occurrence: *anchor]
FAILED tests/test_yaml_suite.py::test_yaml_suite[LHL4----\n!invalid{}tag scalar]
FAILED tests/test_yaml_suite.py::test_yaml_suite[36F6----\nplain: a\n b\n\n c]
FAILED tests/test_yaml_suite.py::test_yaml_suite[RTP8-%YAML 1.2\n---\nDocument\n... # Suffix]
FAILED tests/test_yaml_suite.py::test_yaml_suite[QT73-# comment\n...] - Faile...
FAILED tests/test_yaml_suite.py::test_yaml_suite[FRK4-{\n  ? foo :,\n  : bar,\n}]
FAILED tests/test_yaml_suite.py::test_yaml_suite[2LFX-%FOO  bar baz # Should be ignored\n              # with a warning.\n---\n"foo"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[PW8X-- &a\n- a\n-\n  &a : a\n  b: &b\n-\n  &c : &a\n-\n  ? &d\n-\n  ? &e\n  : &a]
FAILED tests/test_yaml_suite.py::test_yaml_suite[Q4CL-key1: "quoted1"\nkey2: "quoted2" trailing content\nkey3: "quoted3"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[S4JQ-# Assuming conventional resolution:\n- "12"\n- 12\n- ! 12]
FAILED tests/test_yaml_suite.py::test_yaml_suite[HU3P-key:\n  word1 word2\n  no: key]
FAILED tests/test_yaml_suite.py::test_yaml_suite[Z67P-literal: |2\n  value\nfolded: !foo >1\n value]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9U5K----\n# Products purchased\n- item    : Super Hoop\n  quantity: 1\n- item    : Basketball\n  quantity: 4\n- item    : Big Shoes\n  quantity: 1]
FAILED tests/test_yaml_suite.py::test_yaml_suite[33X3----\n- !!int 1\n- !!int -2\n- !!int 33]
FAILED tests/test_yaml_suite.py::test_yaml_suite[J7VC-one: 2\n\n\nthree: 4]
FAILED tests/test_yaml_suite.py::test_yaml_suite[J9HZ----\nhr: # 1998 hr ranking\n  - Mark McGwire\n  - Sammy Sosa\nrbi:\n  # 1998 rbi ranking\n  - Sammy Sosa\n  - Ken Griffey]
FAILED tests/test_yaml_suite.py::test_yaml_suite[UGM3---- !<tag:clarkevans.com,2002:invoice>\ninvoice: 34843\ndate   : 2001-01-23\nbill-to: &id001\n    given  : Chris\n    family : Dumars\n    address:\n        lines: |\n            458 Walkman Dr.\n            Suite #292\n        city    : Royal Oak\n        state   : MI\n        postal  : 48046\nship-to: *id001\nproduct:\n    - sku         : BL394D\n      quantity    : 4\n      description : Basketball\n      price       : 450.00\n    - sku         : BL4438H\n      quantity    : 1\n      description : Super Hoop\n      price       : 2392.00\ntax  : 251.42\ntotal: 4443.52\ncomments:\n    Late afternoon is best.\n    Backup contact is Nancy\n    Billsmer @ 338-4338.]
FAILED tests/test_yaml_suite.py::test_yaml_suite[HMK4-name: Mark McGwire\naccomplishment: >\n  Mark set a major league\n  home run record in 1998.\nstats: |\n  65 Home Runs\n  0.278 Batting Average]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6H3V-'foo: bar\\': baz'] - F...
FAILED tests/test_yaml_suite.py::test_yaml_suite[5GBF-Folding:\n  "Empty line\n   \xbb\n  as a line feed"\nChomping: |\n  Clipped empty lines\n\u2423\n\u21b5]
FAILED tests/test_yaml_suite.py::test_yaml_suite[D49Q-'a\\nb': 1\n'c\n d': 1]
FAILED tests/test_yaml_suite.py::test_yaml_suite[2G84---- |0] - Failed: Faile...
FAILED tests/test_yaml_suite.py::test_yaml_suite[HMQ5-!!str &a1 "foo":\n  !!str bar\n&a2 baz : *a1]
FAILED tests/test_yaml_suite.py::test_yaml_suite[G7JE-a\\nb: 1\nc\n d: 1] - F...
FAILED tests/test_yaml_suite.py::test_yaml_suite[MZX3-- plain\n- "double quoted"\n- 'single quoted'\n- >\n  block\n- plain again]
FAILED tests/test_yaml_suite.py::test_yaml_suite[Q8AD----\n"folded\u2423\nto a space,\n\u2423\nto a line feed, or \xbb\\\n \\ \xbbnon-content"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[G5U8----\n- [-, -]] - Failed...
FAILED tests/test_yaml_suite.py::test_yaml_suite[NB6Z-key:\n  value\n  with\n  \u2014\xbb\n  tabs]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6PBE----\n?\n- a\n- b\n:\n- c\n- d]
FAILED tests/test_yaml_suite.py::test_yaml_suite[ZXT5-[ "key"\n  :value ]] - ...
FAILED tests/test_yaml_suite.py::test_yaml_suite[K4SU-- foo\n- bar\n- 42] - F...
FAILED tests/test_yaml_suite.py::test_yaml_suite[7BMT----\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4: &node4\n  &k4 key4: four\ntop5: &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven]
FAILED tests/test_yaml_suite.py::test_yaml_suite[G4RS-unicode: "Sosa did fine.\\u263A"\ncontrol: "\\b1998\\t1999\\t2000\\n"\nhex esc: "\\x0d\\x0a is \\r\\n"\n\nsingle: '"Howdy!" he cried.'\nquoted: ' # Not a ''comment''.'\ntie-fighter: '|\\-*-/|']
FAILED tests/test_yaml_suite.py::test_yaml_suite[5BVJ-literal: |\n  some\n  text\nfolded: >\n  some\n  text]
FAILED tests/test_yaml_suite.py::test_yaml_suite[8UDB-[\n"double\n quoted", 'single\n           quoted',\nplain\n text, [ nested ],\nsingle: pair,\n]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6M2F-? &a a\n: &b b\n: *a]
FAILED tests/test_yaml_suite.py::test_yaml_suite[EW3V-k1: v1\n k2: v2] - Fail...
FAILED tests/test_yaml_suite.py::test_yaml_suite[LQZ7-"implicit block key" : [\n  "implicit flow key" : value,\n ]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[YJV2-[-]] - Failed: Failed t...
FAILED tests/test_yaml_suite.py::test_yaml_suite[Z9M4-%TAG !e! tag:example.com,2000:app/\n---\n- !e!foo "bar"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6JQW-# ASCII Art\n--- |\n  \\//||\\/||\n  // ||  ||__]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9HCY-!foo "bar"\n%TAG ! tag:example.com,2000:app/\n---\n!foo "bar"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[JHB9-# Ranking of 1998 home runs\n---\n- Mark McGwire\n- Sammy Sosa\n- Ken Griffey\n\n# Team ranking\n---\n- Chicago Cubs\n- St Louis Cardinals]
FAILED tests/test_yaml_suite.py::test_yaml_suite[4FJ6----\n[\n  [ a, [ [[b,c]]: d, e]]: 23\n]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[7LBH-"a\\nb": 1\n"c\n d": 1]
FAILED tests/test_yaml_suite.py::test_yaml_suite[2CMS-this\n is\n  invalid: x]
FAILED tests/test_yaml_suite.py::test_yaml_suite[M7A3-Bare\ndocument\n...\n# No document\n...\n|\n%!PS-Adobe-2.0 # Not the first line]
FAILED tests/test_yaml_suite.py::test_yaml_suite[W42U-- # Empty\n- |\n block node\n- - one # Compact\n  - two # sequence\n- one: two # Compact mapping]
FAILED tests/test_yaml_suite.py::test_yaml_suite[236B-foo:\n  bar\ninvalid]
FAILED tests/test_yaml_suite.py::test_yaml_suite[F6MC----\na: >2\n   more indented\n  regular\nb: >2\n\n\n   more indented\n  regular]
FAILED tests/test_yaml_suite.py::test_yaml_suite[JR7V-- a?string\n- another ? string\n- key: value?\n- [a?string]\n- [another ? string]\n- {key: value? }\n- {key: value?}\n- {key?: value }]
FAILED tests/test_yaml_suite.py::test_yaml_suite[FQ7F-- Mark McGwire\n- Sammy Sosa\n- Ken Griffey]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9YRD-a\nb\u2423\u2423\n  c\nd\n\ne]
FAILED tests/test_yaml_suite.py::test_yaml_suite[H7TQ-%YAML 1.2 foo\n---] - F...
FAILED tests/test_yaml_suite.py::test_yaml_suite[UV7Q-x:\n - x\n  \u2014\u2014\xbbx]
FAILED tests/test_yaml_suite.py::test_yaml_suite[V9D5-- sun: yellow\n- ? earth: blue\n  : moon: white]
FAILED tests/test_yaml_suite.py::test_yaml_suite[NHX8-:\n\u21b5\n\u21b5] - Fa...
FAILED tests/test_yaml_suite.py::test_yaml_suite[RZT7----\nTime: 2001-11-23 15:01:42 -5\nUser: ed\nWarning:\n  This is an error message\n  for the log file\n---\nTime: 2001-11-23 15:02:31 -5\nUser: ed\nWarning:\n  A slightly different error\n  message.\n---\nDate: 2001-11-23 15:03:17 -5\nUser: ed\nFatal:\n  Unknown variable "bar"\nStack:\n  - file: TopClass.py\n    line: 23\n    code: |\n      x = MoreObject("345\\n")\n  - file: MoreClass.py\n    line: 58\n    code: |-\n      foo = bar]
FAILED tests/test_yaml_suite.py::test_yaml_suite[RHX7----\nkey: value\n%YAML 1.2\n---]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9DXL-Mapping: Document\n---\n# Empty\n...\n%YAML 1.2\n---\nmatches %: 20]
FAILED tests/test_yaml_suite.py::test_yaml_suite[DK3J---- >\nline1\n# no comment\nline3]
FAILED tests/test_yaml_suite.py::test_yaml_suite[F8F9-# Strip\n # Comments:]
FAILED tests/test_yaml_suite.py::test_yaml_suite[82AN----word1\nword2] - Fail...
FAILED tests/test_yaml_suite.py::test_yaml_suite[5WE3-? explicit key # Empty value\n? |\n  block key\n: - one # Explicit compact\n  - two # block value]
FAILED tests/test_yaml_suite.py::test_yaml_suite[B63P-%YAML 1.2\n...] - Faile...
FAILED tests/test_yaml_suite.py::test_yaml_suite[KK5P-complex1:\n  ? - a\ncomplex2:\n  ? - a\n  : b\ncomplex3:\n  ? - a\n  : >\n    b\ncomplex4:\n  ? >\n    a\n  :\ncomplex5:\n  ? - a\n  : - b]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6VJK->\n Sammy Sosa completed another\n fine season with great stats.\n\n   63 Home Runs\n   0.288 Batting Average\n\n What a year!]
FAILED tests/test_yaml_suite.py::test_yaml_suite[F2C7-- &a !!str a\n- !!int 2\n- !!int &c 4\n- &d d]
FAILED tests/test_yaml_suite.py::test_yaml_suite[FH7J-- !!str\n-\n  !!null : a\n  b: !!str\n- !!str : !!null]
FAILED tests/test_yaml_suite.py::test_yaml_suite[PBJ2-american:\n  - Boston Red Sox\n  - Detroit Tigers\n  - New York Yankees\nnational:\n  - New York Mets\n  - Chicago Cubs\n  - Atlanta Braves]
FAILED tests/test_yaml_suite.py::test_yaml_suite[CQ3W----\nkey: "missing closing quote]
FAILED tests/test_yaml_suite.py::test_yaml_suite[W4TN-%YAML 1.2\n--- |\n%!PS-Adobe-2.0\n...\n%YAML 1.2\n---\n# Empty\n...]
FAILED tests/test_yaml_suite.py::test_yaml_suite[XLQ9----\nscalar\n%YAML 1.2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[W5VH-a: &:@*!$"<foo>: scalar a\nb: *:@*!$"<foo>:]
FAILED tests/test_yaml_suite.py::test_yaml_suite[U44R-map:\n  key1: "quoted1"\n   key2: "bad indentation"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[BD7L-- item1\n- item2\ninvalid: x]
FAILED tests/test_yaml_suite.py::test_yaml_suite[4CQQ-plain:\n  This unquoted scalar\n  spans many lines.\n\nquoted: "So does this\n  quoted scalar.\\n"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[ZVH3-- key: value\n - item1]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6JWB-foo: !!seq\n  - !!str a\n  - !!map\n    key: !!str value]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9KAX----\n&a1\n!!str\nscalar1\n---\n!!str\n&a2\nscalar2\n---\n&a3\n!!str scalar3\n---\n&a4 !!map\n&a5 !!str key5: value4\n---\na6: 1\n&anchor6 b6: 2\n---\n!!map\n&a8 !!str key8: value7\n---\n!!map\n!!str &a10 key10: value9\n---\n!!str &a11\nvalue11]
FAILED tests/test_yaml_suite.py::test_yaml_suite[E76Z-&a a: &b b\n*b : *a] - ...
FAILED tests/test_yaml_suite.py::test_yaml_suite[M6YH-- |\n x\n-\n foo: bar\n-\n - 42]
FAILED tests/test_yaml_suite.py::test_yaml_suite[D83L-- |2-\n  explicit indent and chomp\n- |-2\n  chomp and explicit indent]
FAILED tests/test_yaml_suite.py::test_yaml_suite[GT5M-- item1\n&node\n- item2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[M5DY-? - Detroit Tigers\n  - Chicago cubs\n:\n  - 2001-07-23\n\n? [ New York Yankees,\n    Atlanta Braves ]\n: [ 2001-07-02, 2001-08-12,\n    2001-08-14 ]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[CC74-%TAG !e! tag:example.com,2000:app/\n---\n!e!foo "bar"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[A2M4-? a\n: -\xbbb\n  -  -\u2014\xbbc\n     - d]
FAILED tests/test_yaml_suite.py::test_yaml_suite[J5UC-foo: blue\nbar: arrr\nbaz: jazz]
FAILED tests/test_yaml_suite.py::test_yaml_suite[CN3R-&flowseq [\n a: b,\n &c c: d,\n { &e e: f },\n &g { g: h }\n]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[7MNF-top1:\n  key1: val1\ntop2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[FBC9-safe: a!"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\n     !"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~\nsafe question mark: ?foo\nsafe colon: :foo\nsafe dash: -foo]
FAILED tests/test_yaml_suite.py::test_yaml_suite[L9U5-implicit block key : [\n  implicit flow key : value,\n ]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[X8DW----\n? key\n# comment\n: value]
FAILED tests/test_yaml_suite.py::test_yaml_suite[S4GJ----\nfolded: > first line\n  second line]
FAILED tests/test_yaml_suite.py::test_yaml_suite[GH63-? a\n: 1.3\nfifteen: d]
FAILED tests/test_yaml_suite.py::test_yaml_suite[7W2P-? a\n? b\nc:] - Failed:...
FAILED tests/test_yaml_suite.py::test_yaml_suite[6LVF-%FOO  bar baz # Should be ignored\n              # with a warning.\n--- "foo"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[4H7K----\n[ a, b, c ] ]] - F...
FAILED tests/test_yaml_suite.py::test_yaml_suite[DBG4-# Outside flow collection:\n- ::vector\n- ": - ()"\n- Up, up, and away!\n- -123\n- http://example.com/foo#bar\n# Inside flow collection:\n- [ ::vector,\n  ": - ()",\n  "Up, up and away!",\n  -123,\n  http://example.com/foo#bar ]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[NKF9----\nkey: value\n: empty key\n---\n{\n key: value, : empty key\n}\n---\n# empty key and value\n:\n---\n# empty key and value\n{ : }]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6HB6-# Leading comment line spaces are\n # neither content nor indentation.]
FAILED tests/test_yaml_suite.py::test_yaml_suite[U9NS----\ntime: 20:03:20\nplayer: Sammy Sosa\naction: strike (miss)\n...\n---\ntime: 20:03:47\nplayer: Sammy Sosa\naction: grand slam\n...]
FAILED tests/test_yaml_suite.py::test_yaml_suite[BF9H----\nplain: a\n       b # end of scalar\n       c]
FAILED tests/test_yaml_suite.py::test_yaml_suite[RR7F-a: 4.2\n? d\n: 23] - Fa...
FAILED tests/test_yaml_suite.py::test_yaml_suite[AB8U-- single multiline\n - sequence entry]
FAILED tests/test_yaml_suite.py::test_yaml_suite[SF5V-%YAML 1.2\n%YAML 1.2\n---]
FAILED tests/test_yaml_suite.py::test_yaml_suite[565N-canonical: !!binary "\\\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\\\n OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+\\\n +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC\\\n AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs="\ngeneric: !!binary |\n R0lGODlhDAAMAIQAAP//9/X17unp5WZmZgAAAOfn515eXvPz7Y6OjuDg4J+fn5\n OTk6enp56enmlpaWNjY6Ojo4SEhP/++f/++f/++f/++f/++f/++f/++f/++f/+\n +f/++f/++f/++f/++f/++SH+Dk1hZGUgd2l0aCBHSU1QACwAAAAADAAMAAAFLC\n AgjoEwnuNAFOhpEMTRiggcz4BNJHrv/zCFcLiwMWYNG84BwwEeECcgggoBADs=\ndescription:\n The binary value above is a tiny arrow encoded as a gif image.]
FAILED tests/test_yaml_suite.py::test_yaml_suite[87E4-'implicit block key' : [\n  'implicit flow key' : value,\n ]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[4HVU-key:\n   - ok\n   - also ok\n  - wrong]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6SLA-"foo\\nbar:baz\\tx \\\\$%^&*()x": 23\n'x\\ny:z\\tx $%^&*()x': 24]
FAILED tests/test_yaml_suite.py::test_yaml_suite[SYW4-hr:  65    # Home runs\navg: 0.278 # Batting average\nrbi: 147   # Runs Batted In]
FAILED tests/test_yaml_suite.py::test_yaml_suite[JY7Z-key1: "quoted1"\nkey2: "quoted2" no key: nor value\nkey3: "quoted3"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[EB22----\nscalar1 # comment\n%YAML 1.2\n---\nscalar2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[AZW3-- bla"keks: foo\n- bla]keks: foo]
FAILED tests/test_yaml_suite.py::test_yaml_suite[H2RW-foo: 1\n\nbar: 2\n\u2423\u2423\u2423\u2423\ntext: |\n  a\n\u2423\u2423\u2423\u2423\n  b\n\n  c\n\u2423\n  d]
FAILED tests/test_yaml_suite.py::test_yaml_suite[TD5N-- item1\n- item2\ninvalid]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6JTT----\n[ [ a, b, c ]] - F...
FAILED tests/test_yaml_suite.py::test_yaml_suite[2AUY-- !!str a\n- b\n- !!int 42\n- d]
FAILED tests/test_yaml_suite.py::test_yaml_suite[EX5H----\na\nb\u2423\u2423\n  c\nd\n\ne]
FAILED tests/test_yaml_suite.py::test_yaml_suite[229Q--\n  name: Mark McGwire\n  hr:   65\n  avg:  0.278\n-\n  name: Sammy Sosa\n  hr:   63\n  avg:  0.288]
FAILED tests/test_yaml_suite.py::test_yaml_suite[93JH-- key: value\n  key2: value2\n-\n  key3: value3]
FAILED tests/test_yaml_suite.py::test_yaml_suite[2JQS-: a\n: b] - Failed: Fai...
FAILED tests/test_yaml_suite.py::test_yaml_suite[S9E8-sequence:\n- one\n- two\nmapping:\n  ? sky\n  : blue\n  sea : green]
FAILED tests/test_yaml_suite.py::test_yaml_suite[5T43-- { "key":value }\n- { "key"::value }]
FAILED tests/test_yaml_suite.py::test_yaml_suite[GDY7-key: value\nthis is #not a: key]
FAILED tests/test_yaml_suite.py::test_yaml_suite[QF4Y-[\nfoo: bar\n]] - Faile...
FAILED tests/test_yaml_suite.py::test_yaml_suite[EXG3----\n---word1\nword2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[DK4H----\n[ key\n  : value ]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[N782-[\n--- ,\n...\n]] - Fai...
FAILED tests/test_yaml_suite.py::test_yaml_suite[BEC7-%YAML 1.3 # Attempt parsing\n          # with a warning\n---\n"foo"]
FAILED tests/test_yaml_suite.py::test_yaml_suite[NAT4----\na: '\n  '\nb: '\u2423\u2423\n  '\nc: "\n  "\nd: "\u2423\u2423\n  "\ne: '\n\n  '\nf: "\n\n  "\ng: '\n\n\n  '\nh: "\n\n\n  "]
FAILED tests/test_yaml_suite.py::test_yaml_suite[MUS6-%YAML 1.1#...\n---] - F...
FAILED tests/test_yaml_suite.py::test_yaml_suite[SR86-key1: &a value\nkey2: &b *a]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9FMG-a:\n  b:\n    c: d\n  e:\n    f: g\nh: i]
FAILED tests/test_yaml_suite.py::test_yaml_suite[P2AD-- | # Empty header\u2193\n literal\n- >1 # Indentation indicator\u2193\n  folded\n- |+ # Chomping indicator\u2193\n keep\n\n- >1- # Both indicators\u2193\n  strip]
FAILED tests/test_yaml_suite.py::test_yaml_suite[735Y--\n  "flow in block"\n- >\n Block scalar\n- !!map # Block collection\n  foo : bar]
FAILED tests/test_yaml_suite.py::test_yaml_suite[JQ4R-block sequence:\n  - one\n  - two : three]
FAILED tests/test_yaml_suite.py::test_yaml_suite[CT4Q-[\n? foo\n bar : baz\n]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[7BUB----\nhr:\n  - Mark McGwire\n  # Following node labeled SS\n  - &SS Sammy Sosa\nrbi:\n  - *SS # Subsequent occurrence\n  - Ken Griffey]
FAILED tests/test_yaml_suite.py::test_yaml_suite[XV9V-Folding:\n  "Empty line\n\n  as a line feed"\nChomping: |\n  Clipped empty lines\n\u2423\n\u21b5]
FAILED tests/test_yaml_suite.py::test_yaml_suite[8XDJ-key: word1\n#  xxx\n  word2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[HS5T-1st non-empty\n\n 2nd non-empty\u2423\n\u2014\u2014\u2014\xbb3rd non-empty]
FAILED tests/test_yaml_suite.py::test_yaml_suite[96L6---- >\n  Mark McGwire's\n  year was crippled\n  by a knee injury.]
FAILED tests/test_yaml_suite.py::test_yaml_suite[7Z25----\nscalar1\n...\nkey: value]
FAILED tests/test_yaml_suite.py::test_yaml_suite[KMK3-foo:\n  bar: 1\nbaz: 2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[CFD4-- [ : empty key ]\n- [: another empty key]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9MMW-- [ YAML : separate ]\n- [ "JSON like":adjacent ]\n- [ {JSON: like}:adjacent ]]
FAILED tests/test_yaml_suite.py::test_yaml_suite[PUW8----\na: b\n---] - Faile...
FAILED tests/test_yaml_suite.py::test_yaml_suite[RLU9-foo:\n- 42\nbar:\n  - 44]
FAILED tests/test_yaml_suite.py::test_yaml_suite[P76L-%TAG !! tag:example.com,2000:app/\n---\n!!int 1 - 3 # Interval, not integer]
FAILED tests/test_yaml_suite.py::test_yaml_suite[6CK3-%TAG !e! tag:example.com,2000:app/\n---\n- !local foo\n- !!str bar\n- !e!tag%21 baz]
FAILED tests/test_yaml_suite.py::test_yaml_suite[2SXE-&a: key: &a value\nfoo:\n  *a:]
FAILED tests/test_yaml_suite.py::test_yaml_suite[2EBW-a!"#$%&'()*+,-./09:;<=>?@AZ[\\]^_`az{|}~: safe\n?foo: safe question mark\n:foo: safe colon\n-foo: safe dash\nthis is#not: a comment]
FAILED tests/test_yaml_suite.py::test_yaml_suite[4ZYM-plain: text\n  lines\nquoted: "text\n  \u2014\xbblines"\nblock: |\n  text\n   \xbblines]
FAILED tests/test_yaml_suite.py::test_yaml_suite[SU74-key1: &alias value1\n&b *alias : value2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[J7PZ-# The !!omap tag is one of the optional types\n# introduced for YAML 1.1. In 1.2, it is not\n# part of the standard tags and should not be\n# enabled by default.\n# Ordered maps are represented as\n# A sequence of mappings, with\n# each mapping having one key\n--- !!omap\n- Mark McGwire: 65\n- Sammy Sosa: 63\n- Ken Griffy: 58]
FAILED tests/test_yaml_suite.py::test_yaml_suite[S4T7-aaa: bbb\n...] - Failed...
FAILED tests/test_yaml_suite.py::test_yaml_suite[ZYU8-%YAML1.1\n---] - Failed...
FAILED tests/test_yaml_suite.py::test_yaml_suite[7FWL-!<tag:yaml.org,2002:str> foo :\n  !<!bar> baz]
FAILED tests/test_yaml_suite.py::test_yaml_suite[9KBC---- key1: value1\n    key2: value2]
FAILED tests/test_yaml_suite.py::test_yaml_suite[T833----\n{\n foo: 1\n bar: 2 }]
FAILED tests/test_yaml_suite.py::test_yaml_suite[7ZZ5----\nnested sequences:\n- - - []\n- - - {}\nkey1: []\nkey2: {}]
FAILED tests/test_yaml_suite.py::test_yaml_suite[U3XV----\ntop1: &node1\n  &k1 key1: one\ntop2: &node2 # comment\n  key2: two\ntop3:\n  &k3 key3: three\ntop4:\n  &node4\n  &k4 key4: four\ntop5:\n  &node5\n  key5: five\ntop6: &val6\n  six\ntop7:\n  &val7 seven]
FAILED tests/test_yaml_suite.py::test_yaml_suite[FP8R---- >\nline1\nline2\nline3]
FAILED tests/test_yaml_suite.py::test_yaml_suite[35KP---- !!map\n? a\n: b\n--- !!seq\n- !!str c\n--- !!str\nd\ne]
FAILED tests/test_yaml_suite.py::test_yaml_suite[S3PD-plain key: in-line value\n: # Both empty\n"quoted key":\n- entry]
FAILED tests/test_yaml_suite.py::test_yaml_suite[DK95-foo:\n \u2014\u2014\u2014\xbbbar]
FAILED tests/test_yaml_suite.py::test_yaml_suite[QLJ7-%TAG !prefix! tag:example.com,2011:\n--- !prefix!A\na: b\n--- !prefix!B\nc: d\n--- !prefix!C\ne: f]
FAILED tests/test_yaml_suite.py::test_yaml_suite[X4QW-block: ># comment\n  scalar]
FAILED tests/test_yaml_suite.py::test_yaml_suite[XW4D-a: "double\n  quotes" # lala\nb: plain\n value  # lala\nc  : #lala\n  d\n? # lala\n - seq1\n: # lala\n - #lala\n  seq2\ne:\n &node # lala\n - x: y\nblock: > # lala\n  abcde]
FAILED tests/test_yaml_suite.py::test_yaml_suite[5TYM-%TAG !m! !my-\n--- # Bulb here\n!m!light fluorescent\n...\n%TAG !m! !my-\n--- # Color here\n!m!light green]
FAILED tests/test_yaml_suite.py::test_yaml_suite[2XXW-# Sets are represented as a\n# Mapping where each key is\n# associated with a null value\n--- !!set\n? Mark McGwire\n? Sammy Sosa\n? Ken Griff]
FAILED tests/test_yaml_suite.py::test_yaml_suite[C4HZ-%TAG ! tag:clarkevans.com,2002:\n--- !shape\n  # Use the ! handle for presenting\n  # tag:clarkevans.com,2002:circle\n- !circle\n  center: &ORIGIN {x: 73, y: 129}\n  radius: 7\n- !line\n  start: *ORIGIN\n  finish: { x: 89, y: 102 }\n- !label\n  start: *ORIGIN\n  color: 0xFFEEBB\n  text: Pretty vector drawing.]
FAILED tests/test_yaml_suite.py::test_yaml_suite[J3BT-# Tabs and spaces\nquoted: "Quoted \u2014\u2014\u2014\xbb"\nblock:\u2014\xbb|\n  void main() {\n  \u2014\xbbprintf("Hello, world!\\n");\n  }]
================== 211 failed, 140 passed in 69.12s (0:01:09) ==================
